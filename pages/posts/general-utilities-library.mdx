import Layout from 'lib/components/layout'
import {} from '@zeit-ui/react'

export const meta = {
  title: 'General utilities library',
  date: '2020-03-22T03:46:59.795Z',
  description: '',
}

## 20.1 概览

1. 这个条款描述了在C++程序中广泛使用的工具；一些用于C++标准库的其他元素。

## 20.2 Utility components

1. 这个副条款包含了一些用于库的其余部分的基础函数和类模板。

  ### 头文件<utility\> 概要

2. 头文件<utility\>定义在这个条款里描述的若干类型和函数模板。
它也定义the template pair和大量用于pair对象操作的函数模板。

  ```
  #include <initializer_list>
  namespace std {
    // 运算符：
    namespace rel_ops {
      template<class T> bool operator!=(const T&, const T&);
      template<class T> bool operator> (const T&, const T&);
      template<class T> bool operator<=(const T&, const T&);
      template<class T> bool operator>=(const T&, const T&);
    }
    // swap：
    template <class T>
    constexpr void swap(T& a, T& b) noexcept(/* 见定义 */ );
    template <class T, size_t N>
    constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);
  
    // exchange：
    template <class T, class U=T> T exchange(T& obj, U&& new_val);
  
    // forward/move：
    template <class T>
    constexpr T&& forward(remove_reference_t<T>& t) noexcept;
    template <class T>
    constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
    template <class T>
    constexpr remove_reference_t<T>&& move(T&&) noexcept;
    template <class T>
    constexpr conditional_t<!is_nothrow_move_constructible_v<T>
                            && is_copy_constructible_v<T>, const T&, T&&>
    move_if_noexcept(T& x) noexcept;
  
    // as_const ：
    template <class T> constexpr add_const_t<T>& as_const(T& t) noexcept;
    template <class T> void as_const(const T&&) = delete;
  
    // declval：
    template <class T>
    add_rvalue_reference_t<T> declval() noexcept; // 作为不求值操作数
  
    // 编译时整数数列
    template<class T, T...> struct integer_sequence;
    template<size_t... I>
    using index_sequence = integer_sequence<size_t, I...>;
    template<class T, T N>
    using make_integer_sequence = integer_sequence<T, /* 见定义 */ >;
    template<size_t N>
    using make_index_sequence = make_integer_sequence<size_t, N>;
    template<class... T>
    using index_sequence_for = make_index_sequence<sizeof...(T)>;
  
    // pair：
    template <class T1, class T2> struct pair;
  
    // 对 pair 特化的算法：
    template <class T1, class T2>
    constexpr bool operator==(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator< (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator!=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator> (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator>=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator<=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
    template <class T1, class T2>
    constexpr /* 见定义 */ make_pair(T1&&, T2&&);
  
    // 对 pair 的 tuple 式访问：
    template <class T> class tuple_size;
    template <size_t I, class T> class tuple_element;
    template <class T1, class T2> struct tuple_size<pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<0, pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<1, pair<T1, T2>>;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&&) noexcept;
    template <class T, class U>
    constexpr T& get(pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr T& get(pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<U, T>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<U, T>&& p) noexcept;
  
    // pair 逐段构造
    struct piecewise_construct_t { };
    constexpr piecewise_construct_t piecewise_construct{};
    template <class... Types> class tuple; // 定义于 <tuple>
  }
  ```

  ### 20.2.1 运算符

  1.为了避免多余定义，!=用==，>,<=和>=使用<。

  `template <class T> bool operator!=(const T& x, const T& y);`

  2.*要求：* T是EqualityComparable。

  3.*返回值：* !(x==y).

  `template <class T> bool operator>(const T& x, const T& y);`

  4.*要求：* T是LessThanComparable。

  5.*返回值：* y<x

  `template <class T> bool operator<=(const T& x, const T& y);`

  6.*要求：* T是LessThanComparable。

  7.*返回值：* !(y<x)

  `template <class T> bool operator>=(const T& x, const T& y);`

  8.*要求：* T是LessThanComparable。

  9.*返回值：* !(x<y)

  10.在这个库，每当对 != , > , >= , <= 进行声明时，
  并且未显示提供要求和语义，则要求和语义均在像本条款中指定的。

  ### 20.2.2 swap

  `template<class T> void swap(T& a, T& b) noexcept(see below);`

  1.*备注：* noexcept里的表达式等价于:

  ```
  is_nothrow_move_constructible<T>::value &&
  is_nothrow_move_assignable<T>::value
  ```

  2.*要求：* T应该是MoveConstructible和MoveAssignable。

  3.*影响:* 交换保存在两个位置的值。

  `template<class T, size_t N>`

  `void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));`

  4.*要求：* 对于[0,N\]内的所有i，a[i\]应可与b[i\]交换。

  5.*影响：* swap_ranges(a,a+N,b)

  ### 20.2.3 forward/move helpers

  1.该库提供了模板化的(helper)函数，以简化将移动语义应用于左值并简化转发功能的实现。

  `template <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;`

  `template <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept;`

  2.*返回值：* static_cast<T&&\>(t)

  3.如果第二个形式被一个左值引用实例化，程序ill-formed。

  4.[*Example:* 
  ```
    template <class T, class A1, class A2>
    shared_ptr<T> factory(A1&& a1, A2&& a2) { 
      return shared_ptr<T>(new T(std::forward<A1>(a1), std::forward<A2>(a2))); 
    }

    struct A { 
      A(int&, const double&); 
    };

    void g() { 
      shared_ptr<A> sp1 = factory<A>(2, 1.414); // error: 2 will not bind to int& 
      int i = 2; 
      shared_ptr<A> sp2 = factory<A>(i, 1.414); // OK 
    } 
  ```
  5.In the ﬁrst call to factory, A1 is deduced as int, so 2 is forwarded to A’s constructor as an rvalue. 
    In the second call to factory, A1 is deduced as int&, so i is forwarded to A’s constructor as an lvalue. 
    In both cases, A2 is deduced as double, so 1.414 is forwarded to A’s constructor as an rvalue.
    *-end note* \]

  6.[*Example:* 
    ```
    template <class T, class A1> 
    shared_ptr<T> factory(A1&& a1) { 
      return shared_ptr<T>(new T(std::forward<A1>(a1))); 
    }

    struct A { 
      A(); 
      A(const A&); // copies from lvalues 
      A(A&&); // moves from rvalues 
    };

    void g() { 
      A a; 
      shared_ptr<A> sp1 = factory<A>(a); // “a” binds to A(const A&) 
      shared_ptr<A> sp1 = factory<A>(std::move(a)); // “a” binds to A(A&&)
    }
    ```
  7.In the ﬁrst call to factory, A1 is deduced as A&, so a is forwarded as a non-const lvalue. 
    This binds to theconstructor A(const A&), which copies the value from a. 
    In the second call to factory, because of the call std::move(a),A1 is deduced as A,so a is forwarded as an rvalue. 
    This binds to the constructor A(A&&), which moves the value from a. 
    *-end note* \]

  `template <class T> typename conditional<`
  
  `!is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,`

  `const T&, T&&>::type move_if_noexcept(T& x) noexcept;`

  8.*返回值：* std::move(x)

  ### 20.2.4 函数模板declval

  1.该库提供函数模板declval,以简化对未求值运算符中出现的表达式的定义。

  `template <class T>`

  `typename add_rvalue_reference<T>::type declval() noexcept; // as unevaluated operand`

  2.*备注：* 如果这个函数被odr式使用，程序ill-formed

  3.*备注：* declval的模板参数T可能是未完成类型。

  [*Example:* 

    ```
    template <class To, class From> 
    decltype(static_cast<To>(declval<From>())) convert(From&&);
    ```
    
  声明一个函数模板convert,仅当From类型可以显式转换为To类型时，该转换才参与重载。
  有关另一个示例，请参见类模板common_type。
  *-end note*\]

## 20.3 Pairs
1.  for align
  ### 20.3.1 概览

  1.该库为合成值对提供了模板。 
  该库还提供了一个匹配功能模板以简化其构造，并提供了多个模板，
  这些模板可以访问pair对象，就像它们是tuple对象一样。

  ### 20.3.2 类模板pair

  ```
  // deﬁned in header <utility>

  namespace std { 
    template <class T1, class T2> 
    struct pair { 
      typedef T1 first_type; 
      typedef T2 second_type;

      T1 first; 
      T2 second; 
      pair(const pair&) = default; 
      pair(pair&&) = default;

      constexpr pair(); 
      pair(const T1& x, const T2& y); 
      template<class U, class V> pair(U&& x, V&& y); 
      template<class U, class V> pair(const pair<U, V>& p); 
      template<class U, class V> pair(pair<U, V>&& p); 
      template <class... Args1, class... Args2> 
      pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);

    pair& operator=(const pair& p); 
    template<class U, class V> pair& operator=(const pair<U, V>& p); 
    pair& operator=(pair&& p) noexcept(see below); 
    template<class U, class V> pair& operator=(pair<U, V>&& p);

    void swap(pair& p) noexcept(see below);
    };
  }
  ```
  1.构造函数和pair成员函数不会抛出异常，除非指定的对此操作调用的元素抛出异常。

  `constexpr pair();`

  2.*要求：* is_default_constructible<first_type\>::value 是 true and 
  is_default_constructible<second_type\>::value 是 true.

  3.*影响：* 值初始化first和second.

  `pair(const T1& x, const T2& y);`

  4.*要求：* is_copy_constructible<first_type\>::value 是 true and 
  is_copy_constructible<second_type\>::value 是 true. 

  5.*影响:* 这个构造函数用x初始化first，用y初始化second.

  `template<class U, class V> pair(U&& x, V&& y);`

  6.*要求：* is_constructible<first_type, U&&\>::value 是 true and 
  is_constructible<second_type, V&&\>::value 是 true. 

  7.*影响：* 这个构造函数用std::forward<U\>(x)初始化first，用std::forward<V\>(y)初始化second.

  8.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的，这个构造函数不得参与重载决议。

  `template<class U, class V> pair(const pair<U, V>& p);`

  9.*要求：* is_constructible<first_type, const U&\>::value 是 true and
  is_constructible<second_type, const V&\>::value 是 true.

  10.*影响：*  从参数对应的成员中初始化。

  11.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的，这个构造函数不得参与重载决议。

  `template<class U, class V> pair(pair<U, V>&& p);`

  12.*要求：* is_constructible<first_type, U&&\>::value 是 true and 
  is_constructible<second_type, V&&\>::value 是 true. 

  13.*影响：* 让std::forward<U\>(p.first)初始化first，std::forward<V\>(p.second)初始化second.

  14.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的，这个构造函数不得参与重载决议。

  `template<class... Args1, class... Args2>`

  `pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);`

  15.*要求：* is_constructible<first_type, Args1&&...\>::value 是 true and 
  is_constructible<second_type, Args2&&...\>::value 是 true. 

  16.*影响：* 让通过转发first_args获得的Args1...类型的参数初始化first,通过转发fsecond_args获得的Args2...类型的参数初始化second.
  这里，转发类型U的一个元素x在tuple对象内意味着调用std::forward<U\>(x).
  这个形式的构造函数，第一和第二个参数分别在单独的tuple对象中提供，称为分段构造。

  `pair& operator=(const pair& p);`

  17.*要求：*  is_copy_assignable<first_type\>::value 是 true and 
  is_copy_assignable<second_type\>::value 是 true. 

  18.*影响：* 用p.first对first赋值，p.second对second.

  19.*返回值：*  *this.

  `template<class U, class V> pair& operator=(const pair<U, V>& p);`

  20.*要求：*  is_assignable<ﬁrst_type&, const U&\>::value 是 true and 
  is_assignable<second_type&, const V&\>::value 是 true. 

  21.*影响：* 同上

  22.*返回值:* 同上

  `pair& operator=(pair&& p) noexcept(see below);`

  23.*备注：* noexcept里的表达式等价于

  ```
  is_nothrow_move_assignable<T1>::value &&
  is_nothrow_move_assignable<T2>::value
  ```

  24.*要求：* is_move_assignable<first_type\>::value is true and 
  is_move_assignable<second_type\>::value is true. 

  25.*影响：* 用std::forward<first_type\>(p.first)对first赋值，std::forward<second_type\>(p.second)对second赋值。

  26.*返回值：* *this

  `template<class U, class V> pair& operator=(pair<U, V>&& p);`

  27.*要求：*   is_assignable<first_type&, U&&\>::value is true and 
  is_assignable<second_type&, V&&\>::value is true.

  28.*影响：* 用std::forward<U\>(p.first)对first赋值，std::forward<V\>(p.second)对second赋值。

  29.*返回值：* *this

  `void swap(pair& p) noexcept(see below);`

  30.*备注：* noexcept里的表达式等价于

  ```
  noexcept(swap(first, p.first)) &&
  noexcept(swap(second, p.second))
  ```

  31.*要求：* first和p.first可交换，second和p.second可交换。

  32.*影响：* 交换first和p.first，second和p.second.

  ### 20.3.3 特化算法(Specialized algorithms)

  `template <class T1, class T2>`

  `bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);`

  1.*返回值：* x.first == y.first && x.second == y.second.

  `template <class T1, class T2>`
  
  `bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);`

  2.*返回值：* x.first < y.first || (!(y.first < x.first) && x.second < y.second )

  #### 剩下的和20.2.1/20.2.2要求一样

  `template<class T1, class T2>`
  
  `pair<V1, V2> make_pair(T1&& x, T2&& y);`

  8.*返回值：*  pair<V1, V2\>(std::forward<T1\>(x), std::forward<T2\>(y)); 

  V1和V2这样确定: 令每个Ui为每个Ti的decay<Ti\>::type。如果Ui等于reference_wrapper<X\>，令每个Vi是X&，否则Vi是Ui。
  (Let Ui be decay<Ti\>::type for each Ti. Then each Vi is X& if Ui equals reference_wrapper<X\>, otherwise Vi is Ui.)

  9.[*Example:* 替代：

    `return pair<int, double>(5,3.1415926); // 隐式类型`

    一个C++程序可能contain:

    `return make_pair(5, 3.1415926); // 类型推断`

    *-end example*]

  ### 20.3.4 像tuple访问pair

  `tuple_size<pair<T1, T2> >::value`

  1.*返回值：* 整数常量表达式。

  2.*值：* 2

  `tuple_element<0, pair<T1, T2> >::type`

  3.*值：* 类型T1

  `tuple_element<1, pair<T1, T2> >::type`

  4.*值：* 类型T2

  ```
  template<size_t I, class T1, class T2> 
  typename tuple_element<I, std::pair<T1, T2> >::type& get(pair<T1, T2>&) noexcept; 
  template<size_t I, class T1, class T2> 
  const typename tuple_element<I, std::pair<T1, T2> >::type& get(const pair<T1, T2>&) noexcept;
  ```

  5.*返回值：* 如果 I == 0 返回p.first;如果 I == 1 返回p.second;否则程序ill-formed。

  ```
  template<size_t I, class T1, class T2> 
  typename tuple_element<I, std::pair<T1, T2> >::type&& get(std::pair<T1, T2>&&) noexcept; 
  ```

  6.*返回值：* 如果 I == 0 返回std::forward<T1&&\>(p1.first);如果 I == 1 返回std::forward<T2&&\>(p.second);
  否则程序ill-formed。

  ### 20.3.5 分段构造(Piecewise construction)

  `struct piecewise_construct_t { };`

  `constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();`

  1.piecewise_construct_t是个空的结构体类型，用作独特的类型来消除构造函数和函数重载的歧义。
  具体来说，pair具有一个piecewise_construct_t作为第一参数的构造函数，随后是两个被用于pair对象的元素的分段构造的tuple元素

## 20.4
1. for align

  ### 20.4.1 概览

  1.本小节描述了提供tuple类型的tuple库，该tuple类型可以作为可以使用任意数量的参数实例化的类模板tuple。
  每个模板参数指定tuple中元素的类型。因此，tuple是异构的固定大小的值集合。
  具有两个参数的tuple的实例化与具有相同两个参数的pair的实例化相似。见20.3。

  2.头文件 <tuple\> 概要

  ```
  namespace std {
    // 20.4.2, class template tuple:
    template <class... Types> class tuple;

    // 20.4.2.4, tuple creation functions:
    const unspecified ignore;

    template <class... Types>
    tuple<VTypes...> make_tuple(Types&&...);
    template <class... Types>
    tuple<Types...> forward_as_tuple(Types&&...) noexcept;

    template<class... Types>
    tuple<Types&...> tie(Types&...) noexcept;

    template <class... Tuples>
    tuple<Ctypes...> tuple_cat(Tuples&&...);

    // 20.4.2.5, tuple helper classes:
    template <class T> class tuple_size; // undeﬁned
    template <class T> class tuple_size<const T>;
    template <class T> class tuple_size<volatile T>;
    template <class T> class tuple_size<const volatile T>

    template <class... Types> class tuple_size<tuple<Types...> >;
    
    template <size_t I, class T> class tuple_element; // undeﬁned
    template <size_t I, class T> class tuple_element<I, const T>;
    template <size_t I, class T> class tuple_element<I, volatile T>;
    template <size_t I, class T> class tuple_element<I, const volatile T>;

    template <size_t I, class... Types> class tuple_element<I, tuple<Types...> >;

    // 20.4.2.6, element access:
    template <size_t I, class... Types>
    typename tuple_element<I, tuple<Types...> >::type& get(tuple<Types...>&) noexcept;
    template <size_t I, class... types>
    typename tuple_element<I, tuple<Types...> >::type&& get(tuple<Types...>&&) noexcept;
    template <size_t I, class... types>
    typename tuple_element<I, tuple<Types...> >::type const& get(const tuple<Types...>&) noexcept;

    // 20.4.2.7, relational operators:
    template<class... TTypes, class... UTypes>
    bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator<(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator!=(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator>(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator<=(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator>=(const tuple<TTypes...>&, const tuple<UTypes...>&);

    // 20.4.2.8, allocator-related traits 
    template <class... Types, class Alloc> 
    struct uses_allocator<tuple<Types...>, Alloc>;

    // 20.4.2.9, specialized algorithms: 
    template <class... Types> 
    void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(see below);
  } 
  ```

  ### 20.4.2 类模板tuple

  ```
  namespace std { 
    template <class... Types> 
    class tuple { 
    public: 
    
      // 20.4.2.1, tuple construction 
      constexpr tuple(); 
      explicit tuple(const Types&...); 
      template <class... UTypes> 
      explicit tuple(UTypes&&...);

      tuple(const tuple&) = default; 
      tuple(tuple&&) = default;

      template <class... UTypes> 
      tuple(const tuple<UTypes...>&); 
      template <class... UTypes> 
      tuple(tuple<UTypes...>&&);

      template <class U1, class U2> 
      tuple(const pair<U1, U2>&); // iﬀ sizeof...(Types) == 2 
      template <class U1, class U2> 
      tuple(pair<U1, U2>&&); // iﬀ sizeof...(Types) == 2


      // allocator-extended constructors 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, const Types&...); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, const UTypes&&...); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, const tuple&); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, tuple&&); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&); 
      template <class Alloc, class U1, class U2> 
      tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&); 
      template <class Alloc, class U1, class U2> 
      tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

      // 20.4.2.2, tuple assignment 
      tuple& operator=(const tuple&); 
      tuple& operator=(tuple&&) noexcept(see below);

      template <class... UTypes> 
      tuple& operator=(const tuple<UTypes...>&); 
      template <class... UTypes> 
      tuple& operator=(tuple<UTypes...>&&);

      template <class U1, class U2> 
      tuple& operator=(const pair<U1, U2>&); // iﬀ sizeof...(Types) == 2 
      template <class U1, class U2> 
      tuple& operator=(pair<U1, U2>&&) noexcept; // iﬀ sizeof...(Types) == 2 
      
      // 20.4.2.3, tuple swap 
      void swap(tuple&) noexcept(see below);
    };
  }
  ```

  #### 20.4.2.1 构造函数

export default ({ children }) => <Layout meta={meta}>{children}</Layout>
