import Layout from 'lib/components/layout'
import {} from '@zeit-ui/react'

export const meta = {
  title: 'General utilities library',
  date: '2020-03-22T03:46:59.795Z',
  description: '',
}

## 20.1 概览

1. 这个条款描述了在C++程序中广泛使用的工具；一些用于C++标准库的其他元素。

## 20.2 Utility components

1. 这个副条款包含了一些用于库的其余部分的基础函数和类模板。

  ### 头文件<utility\> 概要

2. 头文件<utility\>定义在这个条款里描述的若干类型和函数模板。
它也定义the template pair和大量用于pair对象操作的函数模板。

  ```
  #include <initializer_list>
  namespace std {
    // 运算符：
    namespace rel_ops {
      template<class T> bool operator!=(const T&, const T&);
      template<class T> bool operator> (const T&, const T&);
      template<class T> bool operator<=(const T&, const T&);
      template<class T> bool operator>=(const T&, const T&);
    }
    // swap：
    template <class T>
    constexpr void swap(T& a, T& b) noexcept(/* 见定义 */ );
    template <class T, size_t N>
    constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);
  
    // exchange：
    template <class T, class U=T> T exchange(T& obj, U&& new_val);
  
    // forward/move：
    template <class T>
    constexpr T&& forward(remove_reference_t<T>& t) noexcept;
    template <class T>
    constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
    template <class T>
    constexpr remove_reference_t<T>&& move(T&&) noexcept;
    template <class T>
    constexpr conditional_t<!is_nothrow_move_constructible_v<T>
                            && is_copy_constructible_v<T>, const T&, T&&>
    move_if_noexcept(T& x) noexcept;
  
    // as_const ：
    template <class T> constexpr add_const_t<T>& as_const(T& t) noexcept;
    template <class T> void as_const(const T&&) = delete;
  
    // declval：
    template <class T>
    add_rvalue_reference_t<T> declval() noexcept; // 作为不求值操作数
  
    // 编译时整数数列
    template<class T, T...> struct integer_sequence;
    template<size_t... I>
    using index_sequence = integer_sequence<size_t, I...>;
    template<class T, T N>
    using make_integer_sequence = integer_sequence<T, /* 见定义 */ >;
    template<size_t N>
    using make_index_sequence = make_integer_sequence<size_t, N>;
    template<class... T>
    using index_sequence_for = make_index_sequence<sizeof...(T)>;
  
    // pair：
    template <class T1, class T2> struct pair;
  
    // 对 pair 特化的算法：
    template <class T1, class T2>
    constexpr bool operator==(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator< (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator!=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator> (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator>=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator<=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
    template <class T1, class T2>
    constexpr /* 见定义 */ make_pair(T1&&, T2&&);
  
    // 对 pair 的 tuple 式访问：
    template <class T> class tuple_size;
    template <size_t I, class T> class tuple_element;
    template <class T1, class T2> struct tuple_size<pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<0, pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<1, pair<T1, T2>>;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&&) noexcept;
    template <class T, class U>
    constexpr T& get(pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr T& get(pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<U, T>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<U, T>&& p) noexcept;
  
    // pair 逐段构造
    struct piecewise_construct_t { };
    constexpr piecewise_construct_t piecewise_construct{};
    template <class... Types> class tuple; // 定义于 <tuple>
  }
  ```

  ### 20.2.1 运算符

  1.为了避免多余定义，!=用==，>,<=和>=使用<。

  `template <class T> bool operator!=(const T& x, const T& y);`

  2.*要求：* T是EqualityComparable。

  3.*返回值：* !(x==y).

  `template <class T> bool operator>(const T& x, const T& y);`

  4.*要求：* T是LessThanComparable。

  5.*返回值：* y<x

  `template <class T> bool operator<=(const T& x, const T& y);`

  6.*要求：* T是LessThanComparable。

  7.*返回值：* !(y<x)

  `template <class T> bool operator>=(const T& x, const T& y);`

  8.*要求：* T是LessThanComparable。

  9.*返回值：* !(x<y)

  10.在这个库，每当对 != , > , >= , <= 进行声明时，
  并且未显示提供要求和语义，则要求和语义均在像本条款中指定的。

  ### 20.2.2 swap

  `template<class T> void swap(T& a, T& b) noexcept(see below);`

  1.*备注：* noexcept里的表达式等价于:

  ```
  is_nothrow_move_constructible<T>::value &&
  is_nothrow_move_assignable<T>::value
  ```

  2.*要求：* T应该是MoveConstructible和MoveAssignable。

  3.*影响:* 交换保存在两个位置的值。

  `template<class T, size_t N>`

  `void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));`

  4.*要求：* 对于[0,N\]内的所有i，a[i\]应可与b[i\]交换。

  5.*影响：* swap_ranges(a,a+N,b)

  ### 20.2.3 forward/move helpers

  1.该库提供了模板化的(helper)函数，以简化将移动语义应用于左值并简化转发功能的实现。

  `template <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;`

  `template <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept;`

  2.*返回值：* static_cast<T&&\>(t)

  3.如果第二个形式被一个左值引用实例化，程序ill-formed。

  4.[*Example:* 
  ```
    template <class T, class A1, class A2>
    shared_ptr<T> factory(A1&& a1, A2&& a2) { 
      return shared_ptr<T>(new T(std::forward<A1>(a1), std::forward<A2>(a2))); 
    }

    struct A { 
      A(int&, const double&); 
    };

    void g() { 
      shared_ptr<A> sp1 = factory<A>(2, 1.414); // error: 2 will not bind to int& 
      int i = 2; 
      shared_ptr<A> sp2 = factory<A>(i, 1.414); // OK 
    } 
  ```
  5.In the ﬁrst call to factory, A1 is deduced as int, so 2 is forwarded to A’s constructor as an rvalue. 
    In the second call to factory, A1 is deduced as int&, so i is forwarded to A’s constructor as an lvalue. 
    In both cases, A2 is deduced as double, so 1.414 is forwarded to A’s constructor as an rvalue.
    *-end note* \]

  6.[*Example:* 
    ```
    template <class T, class A1> 
    shared_ptr<T> factory(A1&& a1) { 
      return shared_ptr<T>(new T(std::forward<A1>(a1))); 
    }

    struct A { 
      A(); 
      A(const A&); // copies from lvalues 
      A(A&&); // moves from rvalues 
    };

    void g() { 
      A a; 
      shared_ptr<A> sp1 = factory<A>(a); // “a” binds to A(const A&) 
      shared_ptr<A> sp1 = factory<A>(std::move(a)); // “a” binds to A(A&&)
    }
    ```
  7.In the ﬁrst call to factory, A1 is deduced as A&, so a is forwarded as a non-const lvalue. 
    This binds to theconstructor A(const A&), which copies the value from a. 
    In the second call to factory, because of the call std::move(a),A1 is deduced as A,so a is forwarded as an rvalue. 
    This binds to the constructor A(A&&), which moves the value from a. 
    *-end note* \]

  `template <class T> typename conditional<`
  
  `!is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,`

  `const T&, T&&>::type move_if_noexcept(T& x) noexcept;`

  8.*返回值：* std::move(x)

  ### 20.2.4 函数模板declval

  1.该库提供函数模板declval,以简化对未求值运算符中出现的表达式的定义。

  `template <class T>`

  `typename add_rvalue_reference<T>::type declval() noexcept; // as unevaluated operand`

  2.*备注：* 如果这个函数被odr式使用，程序ill-formed

  3.*备注：* declval的模板参数T可能是未完成类型。

  [*Example:* 
    ```
    template <class To, class From> 
    decltype(static_cast<To>(declval<From>())) convert(From&&);
    ```

  声明一个函数模板convert,仅当From类型可以显式转换为To类型时，该转换才参与重载。
  有关另一个示例，请参见类模板common_type。
  *-end note* \]

## 20.3 Pairs
1.  for align
  ### 20.3.1 概览

  1.该库为合成值对提供了模板。 
  该库还提供了一个匹配功能模板以简化其构造，并提供了多个模板，
  这些模板可以访问pair对象，就像它们是tuple对象一样。

  ### 20.3.2 类模板pair

  ```
  // deﬁned in header <utility>

  namespace std { 
    template <class T1, class T2> 
    struct pair { 
      typedef T1 first_type; 
      typedef T2 second_type;

      T1 first; 
      T2 second; 
      pair(const pair&) = default; 
      pair(pair&&) = default;

      constexpr pair(); 
      pair(const T1& x, const T2& y); 
      template<class U, class V> pair(U&& x, V&& y); 
      template<class U, class V> pair(const pair<U, V>& p); 
      template<class U, class V> pair(pair<U, V>&& p); 
      template <class... Args1, class... Args2> 
      pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);

    pair& operator=(const pair& p); 
    template<class U, class V> pair& operator=(const pair<U, V>& p); 
    pair& operator=(pair&& p) noexcept(see below); 
    template<class U, class V> pair& operator=(pair<U, V>&& p);

    void swap(pair& p) noexcept(see below);
    };
  }
  ```
  1.构造函数和pair成员函数不会抛出异常，除非指定的对此操作调用的元素抛出异常。

  `constexpr pair();`

  2.*要求：* is_default_constructible<first_type\>::value 是 true and 
  is_default_constructible<second_type\>::value 是 true.

  3.*影响：* 值初始化first和second.

  `pair(const T1& x, const T2& y);`

  4.*要求：* is_copy_constructible<first_type\>::value 是 true and 
  is_copy_constructible<second_type\>::value 是 true. 

  5.*影响:* 这个构造函数用x初始化first，用y初始化second.

  `template<class U, class V> pair(U&& x, V&& y);`

  6.*要求：* is_constructible<first_type, U&&\>::value 是 true and 
  is_constructible<second_type, V&&\>::value 是 true. 

  7.*影响：* 这个构造函数用std::forward<U\>(x)初始化first，用std::forward<V\>(y)初始化second.

  8.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的，这个构造函数不得参与重载决议。

  `template<class U, class V> pair(const pair<U, V>& p);`

  9.*要求：* is_constructible<first_type, const U&\>::value 是 true and
  is_constructible<second_type, const V&\>::value 是 true.

  10.*影响：*  从参数对应的成员中初始化。

  11.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的，这个构造函数不得参与重载决议。

  `template<class U, class V> pair(pair<U, V>&& p);`

  12.*要求：* is_constructible<first_type, U&&\>::value 是 true and 
  is_constructible<second_type, V&&\>::value 是 true. 

  13.*影响：* 让std::forward<U\>(p.first)初始化first，std::forward<V\>(p.second)初始化second.

  14.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的，这个构造函数不得参与重载决议。

  `template<class... Args1, class... Args2>`

  `pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);`

  15.*要求：* is_constructible<first_type, Args1&&...\>::value 是 true and 
  is_constructible<second_type, Args2&&...\>::value 是 true. 

  16.*影响：* 让通过转发first_args获得的Args1...类型的参数初始化first,通过转发fsecond_args获得的Args2...类型的参数初始化second.
  这里，转发类型U的一个元素x在tuple对象内意味着调用std::forward<U\>(x).
  这个形式的构造函数，第一和第二个参数分别在单独的tuple对象中提供，称为分段构造。

  `pair& operator=(const pair& p);`

  17.*要求：*  is_copy_assignable<first_type\>::value 是 true and 
  is_copy_assignable<second_type\>::value 是 true. 

  18.*影响：* 用p.first对first赋值，p.second对second.

  19.*返回值：*  *this.

  `template<class U, class V> pair& operator=(const pair<U, V>& p);`

  20.*要求：*  is_assignable<ﬁrst_type&, const U&\>::value 是 true and 
  is_assignable<second_type&, const V&\>::value 是 true. 

  21.*影响：* 同上

  22.*返回值:* 同上

  `pair& operator=(pair&& p) noexcept(see below);`

  23.*备注：* noexcept里的表达式等价于

  ```
  is_nothrow_move_assignable<T1>::value &&
  is_nothrow_move_assignable<T2>::value
  ```

  24.*要求：* is_move_assignable<first_type\>::value is true and 
  is_move_assignable<second_type\>::value is true. 

  25.*影响：* 用std::forward<first_type\>(p.first)对first赋值，std::forward<second_type\>(p.second)对second赋值。

  26.*返回值：* *this

  `template<class U, class V> pair& operator=(pair<U, V>&& p);`

  27.*要求：*   is_assignable<first_type&, U&&\>::value is true and 
  is_assignable<second_type&, V&&\>::value is true.

  28.*影响：* 用std::forward<U\>(p.first)对first赋值，std::forward<V\>(p.second)对second赋值。

  29.*返回值：* *this

  `void swap(pair& p) noexcept(see below);`

  30.*备注：* noexcept里的表达式等价于

  ```
  noexcept(swap(first, p.first)) &&
  noexcept(swap(second, p.second))
  ```

  31.*要求：* first和p.first可交换，second和p.second可交换。

  32.*影响：* 交换first和p.first，second和p.second.

  ### 20.3.3 特化算法(Specialized algorithms)

  `template <class T1, class T2>`

  `bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);`

  1.*返回值：* x.first == y.first && x.second == y.second.

  `template <class T1, class T2>`
  
  `bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);`

  2.*返回值：* x.first < y.first || (!(y.first < x.first) && x.second < y.second )

  #### 剩下的和20.2.1/20.2.2要求一样

  `template<class T1, class T2>`
  
  `pair<V1, V2> make_pair(T1&& x, T2&& y);`

  8.*返回值：*  pair<V1, V2\>(std::forward<T1\>(x), std::forward<T2\>(y)); 

  V1和V2这样确定: 令每个Ui为每个Ti的decay<Ti\>::type。如果Ui等于reference_wrapper<X\>，令每个Vi是X&，否则Vi是Ui。
  (Let Ui be decay<Ti\>::type for each Ti. Then each Vi is X& if Ui equals reference_wrapper<X\>, otherwise Vi is Ui.)

  9.[*Example:* 替代：

    `return pair<int, double>(5,3.1415926); // 隐式类型`

    一个C++程序可能contain:

    `return make_pair(5, 3.1415926); // 类型推断`

    *-end example*]

  ### 20.3.4 像tuple访问pair

  `tuple_size<pair<T1, T2> >::value`

  1.*返回值：* 整数常量表达式。

  2.*值：* 2

  `tuple_element<0, pair<T1, T2> >::type`

  3.*值：* 类型T1

  `tuple_element<1, pair<T1, T2> >::type`

  4.*值：* 类型T2

  ```
  template<size_t I, class T1, class T2> 
  typename tuple_element<I, std::pair<T1, T2> >::type& get(pair<T1, T2>&) noexcept; 
  template<size_t I, class T1, class T2> 
  const typename tuple_element<I, std::pair<T1, T2> >::type& get(const pair<T1, T2>&) noexcept;
  ```

  5.*返回值：* 如果 I == 0 返回p.first;如果 I == 1 返回p.second;否则程序ill-formed。

  ```
  template<size_t I, class T1, class T2> 
  typename tuple_element<I, std::pair<T1, T2> >::type&& get(std::pair<T1, T2>&&) noexcept; 
  ```

  6.*返回值：* 如果 I == 0 返回std::forward<T1&&\>(p1.first);如果 I == 1 返回std::forward<T2&&\>(p.second);
  否则程序ill-formed。

  ### 20.3.5 分段构造(Piecewise construction)

  `struct piecewise_construct_t { };`

  `constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();`

  1.piecewise_construct_t是个空的结构体类型，用作独特的类型来消除构造函数和函数重载的歧义。
  具体来说，pair具有一个piecewise_construct_t作为第一参数的构造函数，随后是两个被用于pair对象的元素的分段构造的tuple元素

## 20.4
1. for align

  ### 20.4.1 概览

  1.本小节描述了提供tuple类型的tuple库，该tuple类型可以作为可以使用任意数量的参数实例化的类模板tuple。
  每个模板参数指定tuple中元素的类型。因此，tuple是异构的固定大小的值集合。
  具有两个参数的tuple的实例化与具有相同两个参数的pair的实例化相似。见20.3。

  2.头文件 <tuple\> 概要

  ```
  namespace std {
    // 20.4.2, class template tuple:
    template <class... Types> class tuple;

    // 20.4.2.4, tuple creation functions:
    const unspecified ignore;

    template <class... Types>
    tuple<VTypes...> make_tuple(Types&&...);
    template <class... Types>
    tuple<Types...> forward_as_tuple(Types&&...) noexcept;

    template<class... Types>
    tuple<Types&...> tie(Types&...) noexcept;

    template <class... Tuples>
    tuple<Ctypes...> tuple_cat(Tuples&&...);

    // 20.4.2.5, tuple helper classes:
    template <class T> class tuple_size; // undeﬁned
    template <class T> class tuple_size<const T>;
    template <class T> class tuple_size<volatile T>;
    template <class T> class tuple_size<const volatile T>

    template <class... Types> class tuple_size<tuple<Types...> >;
    
    template <size_t I, class T> class tuple_element; // undeﬁned
    template <size_t I, class T> class tuple_element<I, const T>;
    template <size_t I, class T> class tuple_element<I, volatile T>;
    template <size_t I, class T> class tuple_element<I, const volatile T>;

    template <size_t I, class... Types> class tuple_element<I, tuple<Types...> >;

    // 20.4.2.6, element access:
    template <size_t I, class... Types>
    typename tuple_element<I, tuple<Types...> >::type& get(tuple<Types...>&) noexcept;
    template <size_t I, class... types>
    typename tuple_element<I, tuple<Types...> >::type&& get(tuple<Types...>&&) noexcept;
    template <size_t I, class... types>
    typename tuple_element<I, tuple<Types...> >::type const& get(const tuple<Types...>&) noexcept;

    // 20.4.2.7, relational operators:
    template<class... TTypes, class... UTypes>
    bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator<(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator!=(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator>(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator<=(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator>=(const tuple<TTypes...>&, const tuple<UTypes...>&);

    // 20.4.2.8, allocator-related traits 
    template <class... Types, class Alloc> 
    struct uses_allocator<tuple<Types...>, Alloc>;

    // 20.4.2.9, specialized algorithms: 
    template <class... Types> 
    void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(see below);
  } 
  ```

  ### 20.4.2 类模板tuple

  ```
  namespace std { 
    template <class... Types> 
    class tuple { 
    public: 
    
      // 20.4.2.1, tuple construction 
      constexpr tuple(); 
      explicit tuple(const Types&...); 
      template <class... UTypes> 
      explicit tuple(UTypes&&...);

      tuple(const tuple&) = default; 
      tuple(tuple&&) = default;

      template <class... UTypes> 
      tuple(const tuple<UTypes...>&); 
      template <class... UTypes> 
      tuple(tuple<UTypes...>&&);

      template <class U1, class U2> 
      tuple(const pair<U1, U2>&); // iﬀ sizeof...(Types) == 2 
      template <class U1, class U2> 
      tuple(pair<U1, U2>&&); // iﬀ sizeof...(Types) == 2
      
      // allocator-extended constructors 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, const Types&...); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, const UTypes&&...); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, const tuple&); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, tuple&&); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&); 
      template <class Alloc, class U1, class U2> 
      tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&); 
      template <class Alloc, class U1, class U2> 
      tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

      // 20.4.2.2, tuple assignment 
      tuple& operator=(const tuple&); 
      tuple& operator=(tuple&&) noexcept(see below);

      template <class... UTypes> 
      tuple& operator=(const tuple<UTypes...>&); 
      template <class... UTypes> 
      tuple& operator=(tuple<UTypes...>&&);

      template <class U1, class U2> 
      tuple& operator=(const pair<U1, U2>&); // iﬀ sizeof...(Types) == 2 
      template <class U1, class U2> 
      tuple& operator=(pair<U1, U2>&&) noexcept; // iﬀ sizeof...(Types) == 2 
      
      // 20.4.2.3, tuple swap 
      void swap(tuple&) noexcept(see below);
    };
  }
  ```

  #### 20.4.2.1 构造函数
  
  1.对每个构造函数来说，仅在Types中的一个类型构造函数中抛出异常。

  2.In the constructor descriptions that follow, let i be in the range [0,sizeof...(Types)) in order, Ti be the ith type in Types, and Ui be the ith type in a template parameter pack named UTypes, where indexing is zero-based.

  `constexpr tuple();`
  
  3.*要求：* 每个i，is_default_constructible<Ti\>::value 是true.

  4.*影响：* 值初始化每个元素。

  `explicit tuple(const Types&...);`

  5.*要求：* 每个i，is_copy_constructible<Ti\>::value 是true.

  6.*影响：* 使用相应的参数初始化每个元素。

  `template <class... UTypes> explicit tuple(UTypes&&... u); `

  7.*要求：* sizeof...(Types)==sizeof...(UTypes). is_constructible<Ti, Ui&&\>::value is true for all i.

  8.*影响：* 用在std::forward<UTypes\>(u)中的相应的值初始化tuple中的每个元素。

  9.*备注：* 这个构造函数不参与重载决议，除非每个UTypes中的类型可以隐式转换成在Types中对应的类型。

  `tuple(const tuple& u) = default;`

  10.*要求：* 每个i，is_copy_constructible<Ti\>::value 是true.

  11.*影响：* 用对应的u的元素初始化每个*this的元素 

  `tuple(tuple&& u) = default;`

  12.*要求：* 每个i，is_move_constructible<Ti\>::value 是true.

  13.*影响：* For all i, initializes the ith element of *this with std::forward<Ti\>(get<i\>(u)). 

  `template <class... UTypes> tuple(const tuple<UTypes...>& u);`

  14.*要求：*  sizeof...(Types) == sizeof...(UTypes). is_constructible<Ti, const Ui&\>::value is true for all i.

  15.*影响：* 用对应的u的元素构造每个*this的元素

  16.*备注：* 这个构造函数不参与重载决议，除非每个i，const Ui&可以隐式转换到Ti。

  `template <class... UTypes> tuple(tuple<UTypes...>&& u);`

  17.*要求：*  sizeof...(Types)==sizeof...(UTypes). is_constructible<Ti, Ui&&\>::value is true for all i. 

  18.*影响：*   对全部i，std::forward<Ui\>(get<i\>(u))用初始化*this的第i个元素。

  19.*备注：* 这个构造函数不参与重载决议，除非UTypes的每个类型可以隐式转换从在Types中对应的类型。

  `template <class U1, class U2> tuple(const pair<U1, U2>& u);`

  20.*要求：* sizeof...(Types) == 2. 
  对第一个类型T0来说，is_constructible<T0, const U1&\>::value 是true，对第二个类型T1来说，is_constructible<T1, const U2&\>::value 是true

  21.*影响：* 用u.first构造第一个元素，u.second构造第二个元素。

  22.*备注：* 这个构造函数不参加重载决议，除非const U1& 可隐式转换到T0，const U2& 可隐式转换到T1.

  `template <class U1, class U2> tuple(pair<U1, U2>&& u);`

  23.*要求：*  sizeof...(Types) == 2.
  对第一个类型T0来说，is_constructible<T0, U1&&\>::value 是true，对第二个类型T1来说，is_constructible<T1, U2&&\>::value 是true. 

  24.*影响：* 用std::forward<U1\>(u.first)初始化第一个元素，std::forward<U2\>(u.second)初始化第二个元素。

  25.*备注：* 这个构造函数不参与重载决议，除非U1可隐式转换到T0，U2可隐式转换到T1.

  ```
  template <class Alloc> 
  tuple(allocator_arg_t, const Alloc& a); 
  template <class Alloc> 
  tuple(allocator_arg_t, const Alloc& a, const Types&...); 
  template <class Alloc, class... UTypes> 
  tuple(allocator_arg_t, const Alloc& a, const UTypes&&...); 
  template <class Alloc> 
  tuple(allocator_arg_t, const Alloc& a, const tuple&); 
  template <class Alloc> 
  tuple(allocator_arg_t, const Alloc& a, tuple&&); 
  template <class Alloc, class... UTypes> 
  tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&); 
  template <class Alloc, class... UTypes> 
  tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&); 
  template <class Alloc, class U1, class U2> 
  tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&); 
  template <class Alloc, class U1, class U2> 
  tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
  ```

  26.*要求：* Alloc应该满足Allocator(17.6.3.5)的要求。

  27.*影响：* 等价于前面的构造函数，不同之处在于每个元素都是使用uses_allocator(?)构造的。

  #### 20.4.2.2 赋值(Assignment)

  1.对于每个tuple赋值运算符，仅当Types中的一种类型的赋值引发异常时，才会引发异常。
  在下面的函数描述中，按顺序让i在[0，sizeof ...(Types))范围内，Ti是Types中的第i个类型，Ui是名为UTypes的模板参数包中的第i个类型，
  其中，index是从0开始的。

  `tuple& operator=(const tuple& u);`

  2.*要求：* 每个i，is_copy_assignable<Ti\>::value 是true。

  3.*影响：* 令每个u的元素赋值给对应的*this的元素。

  4.*返回值：* *this

  `tuple& operator=(tuple&& u) noexcept(see below);`

  5.*备注：* noexcept里的表达式等价于下面表达式的logical AND:

  ```
  is_nothrow_move_assignable<Ti>::value 
  ```

  Ti是Types里的第i个类型。

  6.*要求：* 每个i，is_move_assignable<Ti\>::value 是true。

  7.*影响：* 对于全部的i,令std::forward<Ti\>(get<i\>(u))赋值给get<i\>(*this).

  8.*返回值：* *this.

  `template <class... UTypes> tuple& operator=(const tuple<UTypes...>& u);`

  9.*要求：* sizeof...(Types) == sizeof...(UTypes).
  每个i，is_assignable<Ti&,const Ui&\>::value是true.

  10.*影响：* 令每个u的元素赋值给对应的*this的元素。

  11.*返回值：* *this

  `template <class... UTypes> tuple& operator=(tuple<UTypes...>&& u);`

  12.*要求：* 每个i，is_assignable<Ti&, Ui&&\>::value == true.
  sizeof...(Types) == sizeof...(UTypes). 

  13.*影响：* 每个i，令std::forward<Ui\>(get<i\>(u))赋值给get<i\>(*this).

  14.*返回值：* *this.

  `template <class U1, class U2> tuple& operator=(const pair<U1, U2>& u);`

  15.*要求：* sizeof...(Types) == 2.
  对第一个类型T0来说，is_assignable<T0&, const U1&\>::value 是true.
  对第二个类型T1来说，is_assignable<T1&, const U2&\>::value 是true.

  16.*影响：* 令u.first赋值给*this的第一个元素，u.second赋值给 *this的第二个元素

  17.*返回值：* *this

  `template <class U1, class U2> tuple& operator=(pair<U1, U2>&& u);`

  18.*要求：* sizeof...(Types) == 2. 
  对第一个类型T0来说，is_assignable<T0&, U2&&\>::value 是true。
  对第二个类型T1来说，is_assignable<T1&, U2&&\>::value 是true。

  19.*影响：* 令std::forward<U1\>(u.first)赋值给*this的第一个元素，
  std::forward<U2\>(u.second)赋值给 *this的第二个元素。

  20.*返回值：* *this

  #### 20.4.2.3 swap

  `void swap(tuple& rhs) noexcept(see below);`

  1.*备注：* noexcept里的表达式等价于下面表达式的logical：

  ```
  noexcept(swap(declval<Ti&>>(), declval<Ti&>())) 
  ```

  Ti是Types里的第i个类型。

  2.*要求：* 每个*this里的元素应该和rhs对应的元素可交换

  3.*影响:* 对*this的每个元素和rhs中相应的元素调用swap

  4.*Throws:* 无除非一个逐元素swap调用抛出异常。

  #### 20.4.2.4 创建tuple函数(Tuple creation functions)

  1.在下面的函数描述中，按顺序让i在[0，sizeof ...(TTypes))范围内，并让Ti为名为TTypes的模板参数包中的第i个类型； 
  让j按顺序在[0，sizeof ...(UTypes))范围内，并且Uj是名为UTypes的模板参数包中的第j个类型，其中index从0开始。

  `template<class... Types>`

  `tuple<VTypes...> make_tuple(Types&&... t);`

  2.每个i，Ui是decay<Ti\>::type.如果Ui等价于reference_wrapper<X\>,VTypes的每个Vi是X&，否则Vi是Ui。

  3.*返回值：* tuple<VTypes...\>(std::forward<Types\>(t)...)

  4.[*Example:*
  ```
  int i; float j;
  make_tuple(i,ref(i),cref(j))

  创建一个如下类型的tuple

  tuple<int, int&, const float&>
  ```
  *-end example* ]







export default ({ children }) => <Layout meta={meta}>{children}</Layout>
