import Layout from 'lib/components/layout'
import {} from '@zeit-ui/react'

export const meta = {
  title: 'General utilities library',
  date: '2020-03-22T03:46:59.795Z',
  description: '',
}

## 20.1 概览

1. 这个条款描述了在C++程序中广泛使用的工具；一些用于C++标准库的其他元素。

## 20.2 Utility components

1. 这个副条款包含了一些用于库的其余部分的基础函数和类模板。

  ### 头文件<utility\> 概要

2. 头文件<utility\>定义在这个条款里描述的若干类型和函数模板。
它也定义the template pair和大量用于pair对象操作的函数模板。

  ```
  #include <initializer_list>
  namespace std {
    // 运算符：
    namespace rel_ops {
      template<class T> bool operator!=(const T&, const T&);
      template<class T> bool operator> (const T&, const T&);
      template<class T> bool operator<=(const T&, const T&);
      template<class T> bool operator>=(const T&, const T&);
    }
    // swap：
    template <class T>
    constexpr void swap(T& a, T& b) noexcept(/* 见定义 */ );
    template <class T, size_t N>
    constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);
  
    // exchange：
    template <class T, class U=T> T exchange(T& obj, U&& new_val);
  
    // forward/move：
    template <class T>
    constexpr T&& forward(remove_reference_t<T>& t) noexcept;
    template <class T>
    constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
    template <class T>
    constexpr remove_reference_t<T>&& move(T&&) noexcept;
    template <class T>
    constexpr conditional_t<!is_nothrow_move_constructible_v<T>
                            && is_copy_constructible_v<T>, const T&, T&&>
    move_if_noexcept(T& x) noexcept;
  
    // as_const ：
    template <class T> constexpr add_const_t<T>& as_const(T& t) noexcept;
    template <class T> void as_const(const T&&) = delete;
  
    // declval：
    template <class T>
    add_rvalue_reference_t<T> declval() noexcept; // 作为不求值操作数
  
    // 编译时整数数列
    template<class T, T...> struct integer_sequence;
    template<size_t... I>
    using index_sequence = integer_sequence<size_t, I...>;
    template<class T, T N>
    using make_integer_sequence = integer_sequence<T, /* 见定义 */ >;
    template<size_t N>
    using make_index_sequence = make_integer_sequence<size_t, N>;
    template<class... T>
    using index_sequence_for = make_index_sequence<sizeof...(T)>;
  
    // pair：
    template <class T1, class T2> struct pair;
  
    // 对 pair 特化的算法：
    template <class T1, class T2>
    constexpr bool operator==(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator< (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator!=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator> (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator>=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator<=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
    template <class T1, class T2>
    constexpr /* 见定义 */ make_pair(T1&&, T2&&);
  
    // 对 pair 的 tuple 式访问：
    template <class T> class tuple_size;
    template <size_t I, class T> class tuple_element;
    template <class T1, class T2> struct tuple_size<pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<0, pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<1, pair<T1, T2>>;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&&) noexcept;
    template <class T, class U>
    constexpr T& get(pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr T& get(pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<U, T>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<U, T>&& p) noexcept;
  
    // pair 逐段构造
    struct piecewise_construct_t { };
    constexpr piecewise_construct_t piecewise_construct{};
    template <class... Types> class tuple; // 定义于 <tuple>
  }
  ```

  ### 20.2.1 运算符

  1.为了避免多余定义，!=用==，>,<=和>=使用<。

  `template <class T> bool operator!=(const T& x, const T& y);`

  2.*要求：* T是EqualityComparable。

  3.*返回值：* !(x==y).

  `template <class T> bool operator>(const T& x, const T& y);`

  4.*要求：* T是LessThanComparable。

  5.*返回值：* y<x









export default ({ children }) => <Layout meta={meta}>{children}</Layout>
