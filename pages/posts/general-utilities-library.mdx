import Layout from 'lib/components/layout'
import {} from '@zeit-ui/react'

export const meta = {
  title: 'General utilities library',
  date: '2020-03-22T03:46:59.795Z',
  description: '',
}

## 20.1 概览

1. 这个条款描述了在C++程序中广泛使用的工具；一些用于C++标准库的其他元素.

## 20.2 Utility components

1. 这个副条款包含了一些用于库的其余部分的基础函数和类模板.

  ### 头文件<utility\> 概要

2. 头文件<utility\>定义在这个条款里描述的若干类型和函数模板.
它也定义the template pair和大量用于pair对象操作的函数模板.

  ```
  #include <initializer_list>
  namespace std {
    // 运算符：
    namespace rel_ops {
      template<class T> bool operator!=(const T&, const T&);
      template<class T> bool operator> (const T&, const T&);
      template<class T> bool operator<=(const T&, const T&);
      template<class T> bool operator>=(const T&, const T&);
    }
    // swap：
    template <class T>
    constexpr void swap(T& a, T& b) noexcept(/* 见定义 */ );
    template <class T, size_t N>
    constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);
  
    // exchange：
    template <class T, class U=T> T exchange(T& obj, U&& new_val);
  
    // forward/move：
    template <class T>
    constexpr T&& forward(remove_reference_t<T>& t) noexcept;
    template <class T>
    constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
    template <class T>
    constexpr remove_reference_t<T>&& move(T&&) noexcept;
    template <class T>
    constexpr conditional_t<!is_nothrow_move_constructible_v<T>
                            && is_copy_constructible_v<T>, const T&, T&&>
    move_if_noexcept(T& x) noexcept;
  
    // as_const ：
    template <class T> constexpr add_const_t<T>& as_const(T& t) noexcept;
    template <class T> void as_const(const T&&) = delete;
  
    // declval：
    template <class T>
    add_rvalue_reference_t<T> declval() noexcept; // 作为不求值操作数
  
    // 编译时整数数列
    template<class T, T...> struct integer_sequence;
    template<size_t... I>
    using index_sequence = integer_sequence<size_t, I...>;
    template<class T, T N>
    using make_integer_sequence = integer_sequence<T, /* 见定义 */ >;
    template<size_t N>
    using make_index_sequence = make_integer_sequence<size_t, N>;
    template<class... T>
    using index_sequence_for = make_index_sequence<sizeof...(T)>;
  
    // pair：
    template <class T1, class T2> struct pair;
  
    // 对 pair 特化的算法：
    template <class T1, class T2>
    constexpr bool operator==(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator< (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator!=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator> (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator>=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator<=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
    template <class T1, class T2>
    constexpr /* 见定义 */ make_pair(T1&&, T2&&);
  
    // 对 pair 的 tuple 式访问：
    template <class T> class tuple_size;
    template <size_t I, class T> class tuple_element;
    template <class T1, class T2> struct tuple_size<pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<0, pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<1, pair<T1, T2>>;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&&) noexcept;
    template <class T, class U>
    constexpr T& get(pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr T& get(pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<U, T>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<U, T>&& p) noexcept;
  
    // pair 逐段构造
    struct piecewise_construct_t { };
    constexpr piecewise_construct_t piecewise_construct{};
    template <class... Types> class tuple; // 定义于 <tuple>
  }
  ```

  ### 20.2.1 运算符

  1.为了避免多余定义, !=用==, >,<=和>=使用<.

  `template <class T> bool operator!=(const T& x, const T& y);`

  2.*要求：* T是EqualityComparable.

  3.*返回值：* !(x==y).

  `template <class T> bool operator>(const T& x, const T& y);`

  4.*要求：* T是LessThanComparable.

  5.*返回值：* y<x

  `template <class T> bool operator<=(const T& x, const T& y);`

  6.*要求：* T是LessThanComparable.

  7.*返回值：* !(y<x)

  `template <class T> bool operator>=(const T& x, const T& y);`

  8.*要求：* T是LessThanComparable.

  9.*返回值：* !(x<y)

  10.在这个库, 每当对 != , > , >= , <= 进行声明时, 
  并且未显示提供要求和语义, 则要求和语义均在像本条款中指定的.

  ### 20.2.2 swap

  `template<class T> void swap(T& a, T& b) noexcept(see below);`

  1.*备注：* noexcept里的表达式等价于:

  ```
  is_nothrow_move_constructible<T>::value &&
  is_nothrow_move_assignable<T>::value
  ```

  2.*要求：* T应该是MoveConstructible和MoveAssignable.

  3.*影响:* 交换保存在两个位置的值.

  `template<class T, size_t N>`

  `void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));`

  4.*要求：* 对于[0,N\]内的所有i, a[i\]应可与b[i\]交换.

  5.*影响：* swap_ranges(a,a+N,b)

  ### 20.2.3 forward/move helpers

  1.该库提供了模板化的(helper)函数, 以简化将移动语义应用于左值并简化转发功能的实现.

  `template <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;`

  `template <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept;`

  2.*返回值：* static_cast<T&&\>(t)

  3.如果第二个形式被一个左值引用实例化, 程序ill-formed.

  4.[*Example:* 
  ```
    template <class T, class A1, class A2>
    shared_ptr<T> factory(A1&& a1, A2&& a2) { 
      return shared_ptr<T>(new T(std::forward<A1>(a1), std::forward<A2>(a2))); 
    }

    struct A { 
      A(int&, const double&); 
    };

    void g() { 
      shared_ptr<A> sp1 = factory<A>(2, 1.414); // error: 2 will not bind to int& 
      int i = 2; 
      shared_ptr<A> sp2 = factory<A>(i, 1.414); // OK 
    } 
  ```
  5.In the ﬁrst call to factory, A1 is deduced as int, so 2 is forwarded to A’s constructor as an rvalue. 
    In the second call to factory, A1 is deduced as int&, so i is forwarded to A’s constructor as an lvalue. 
    In both cases, A2 is deduced as double, so 1.414 is forwarded to A’s constructor as an rvalue.
    *-end note* \]

  6.[*Example:* 
    ```
    template <class T, class A1> 
    shared_ptr<T> factory(A1&& a1) { 
      return shared_ptr<T>(new T(std::forward<A1>(a1))); 
    }

    struct A { 
      A(); 
      A(const A&); // copies from lvalues 
      A(A&&); // moves from rvalues 
    };

    void g() { 
      A a; 
      shared_ptr<A> sp1 = factory<A>(a); // “a” binds to A(const A&) 
      shared_ptr<A> sp1 = factory<A>(std::move(a)); // “a” binds to A(A&&)
    }
    ```
  7.In the ﬁrst call to factory, A1 is deduced as A&, so a is forwarded as a non-const lvalue. 
    This binds to theconstructor A(const A&), which copies the value from a. 
    In the second call to factory, because of the call std::move(a),A1 is deduced as A,so a is forwarded as an rvalue. 
    This binds to the constructor A(A&&), which moves the value from a. 
    *-end note* \]

  `template <class T> typename conditional<`
  
  `!is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,`

  `const T&, T&&>::type move_if_noexcept(T& x) noexcept;`

  8.*返回值：* std::move(x)

  ### 20.2.4 函数模板declval

  1.该库提供函数模板declval,以简化对未求值运算符中出现的表达式的定义.

  `template <class T>`

  `typename add_rvalue_reference<T>::type declval() noexcept; // as unevaluated operand`

  2.*备注：* 如果这个函数被odr式使用, 程序ill-formed

  3.*备注：* declval的模板参数T可能是未完成类型.

  [*Example:* 
    ```
    template <class To, class From> 
    decltype(static_cast<To>(declval<From>())) convert(From&&);
    ```

  声明一个函数模板convert,仅当From类型可以显式转换为To类型时, 该转换才参与重载.
  有关另一个示例, 请参见类模板common_type.
  *-end note* \]

## 20.3 Pairs
1.  for align
  ### 20.3.1 概览

  1.该库为合成值对提供了模板. 
  该库还提供了一个匹配功能模板以简化其构造, 并提供了多个模板, 
  这些模板可以访问pair对象, 就像它们是tuple对象一样.

  ### 20.3.2 类模板pair

  ```
  // deﬁned in header <utility>

  namespace std { 
    template <class T1, class T2> 
    struct pair { 
      typedef T1 first_type; 
      typedef T2 second_type;

      T1 first; 
      T2 second; 
      pair(const pair&) = default; 
      pair(pair&&) = default;

      constexpr pair(); 
      pair(const T1& x, const T2& y); 
      template<class U, class V> pair(U&& x, V&& y); 
      template<class U, class V> pair(const pair<U, V>& p); 
      template<class U, class V> pair(pair<U, V>&& p); 
      template <class... Args1, class... Args2> 
      pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);

    pair& operator=(const pair& p); 
    template<class U, class V> pair& operator=(const pair<U, V>& p); 
    pair& operator=(pair&& p) noexcept(see below); 
    template<class U, class V> pair& operator=(pair<U, V>&& p);

    void swap(pair& p) noexcept(see below);
    };
  }
  ```
  1.构造函数和pair成员函数不会抛出异常, 除非指定的对此操作调用的元素抛出异常.

  `constexpr pair();`

  2.*要求：* is_default_constructible<first_type\>::value 是 true and 
  is_default_constructible<second_type\>::value 是 true.

  3.*影响：* 值初始化first和second.

  `pair(const T1& x, const T2& y);`

  4.*要求：* is_copy_constructible<first_type\>::value 是 true and 
  is_copy_constructible<second_type\>::value 是 true. 

  5.*影响:* 这个构造函数用x初始化first, 用y初始化second.

  `template<class U, class V> pair(U&& x, V&& y);`

  6.*要求：* is_constructible<first_type, U&&\>::value 是 true and 
  is_constructible<second_type, V&&\>::value 是 true. 

  7.*影响：* 这个构造函数用std::forward<U\>(x)初始化first, 用std::forward<V\>(y)初始化second.

  8.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的, 这个构造函数不得参与重载决议.

  `template<class U, class V> pair(const pair<U, V>& p);`

  9.*要求：* is_constructible<first_type, const U&\>::value 是 true and
  is_constructible<second_type, const V&\>::value 是 true.

  10.*影响：*  从参数对应的成员中初始化.

  11.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的, 这个构造函数不得参与重载决议.

  `template<class U, class V> pair(pair<U, V>&& p);`

  12.*要求：* is_constructible<first_type, U&&\>::value 是 true and 
  is_constructible<second_type, V&&\>::value 是 true. 

  13.*影响：* 让std::forward<U\>(p.first)初始化first, std::forward<V\>(p.second)初始化second.

  14.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的, 这个构造函数不得参与重载决议.

  `template<class... Args1, class... Args2>`

  `pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);`

  15.*要求：* is_constructible<first_type, Args1&&...\>::value 是 true and 
  is_constructible<second_type, Args2&&...\>::value 是 true. 

  16.*影响：* 让通过转发first_args获得的Args1...类型的参数初始化first,通过转发fsecond_args获得的Args2...类型的参数初始化second.
  这里, 转发类型U的一个元素x在tuple对象内意味着调用std::forward<U\>(x).
  这个形式的构造函数, 第一和第二个参数分别在单独的tuple对象中提供, 称为分段构造.

  `pair& operator=(const pair& p);`

  17.*要求：*  is_copy_assignable<first_type\>::value 是 true and 
  is_copy_assignable<second_type\>::value 是 true. 

  18.*影响：* 用p.first对first赋值, p.second对second.

  19.*返回值：*  *this.

  `template<class U, class V> pair& operator=(const pair<U, V>& p);`

  20.*要求：*  is_assignable<ﬁrst_type&, const U&\>::value 是 true and 
  is_assignable<second_type&, const V&\>::value 是 true. 

  21.*影响：* 同上

  22.*返回值:* 同上

  `pair& operator=(pair&& p) noexcept(see below);`

  23.*备注：* noexcept里的表达式等价于

  ```
  is_nothrow_move_assignable<T1>::value &&
  is_nothrow_move_assignable<T2>::value
  ```

  24.*要求：* is_move_assignable<first_type\>::value is true and 
  is_move_assignable<second_type\>::value is true. 

  25.*影响：* 用std::forward<first_type\>(p.first)对first赋值, std::forward<second_type\>(p.second)对second赋值.

  26.*返回值：* *this

  `template<class U, class V> pair& operator=(pair<U, V>&& p);`

  27.*要求：*   is_assignable<first_type&, U&&\>::value is true and 
  is_assignable<second_type&, V&&\>::value is true.

  28.*影响：* 用std::forward<U\>(p.first)对first赋值, std::forward<V\>(p.second)对second赋值.

  29.*返回值：* *this

  `void swap(pair& p) noexcept(see below);`

  30.*备注：* noexcept里的表达式等价于

  ```
  noexcept(swap(first, p.first)) &&
  noexcept(swap(second, p.second))
  ```

  31.*要求：* first和p.first可交换, second和p.second可交换.

  32.*影响：* 交换first和p.first, second和p.second.

  ### 20.3.3 特化算法(Specialized algorithms)

  `template <class T1, class T2>`

  `bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);`

  1.*返回值：* x.first == y.first && x.second == y.second.

  `template <class T1, class T2>`
  
  `bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);`

  2.*返回值：* x.first < y.first || (!(y.first < x.first) && x.second < y.second )

  ##### 剩下的和20.2.1/20.2.2要求一样

  `template<class T1, class T2>`
  
  `pair<V1, V2> make_pair(T1&& x, T2&& y);`

  8.*返回值：*  pair<V1, V2\>(std::forward<T1\>(x), std::forward<T2\>(y)); 

  V1和V2这样确定: 令每个Ui为每个Ti的decay<Ti\>::type.如果Ui等于reference_wrapper<X\>, 令每个Vi是X&, 否则Vi是Ui.
  (Let Ui be decay<Ti\>::type for each Ti. Then each Vi is X& if Ui equals reference_wrapper<X\>, otherwise Vi is Ui.)

  9.[*Example:* 替代：

    `return pair<int, double>(5,3.1415926); // 隐式类型`

    一个C++程序可能contain:

    `return make_pair(5, 3.1415926); // 类型推断`

    *-end example*]

  ### 20.3.4 像tuple访问pair

  `tuple_size<pair<T1, T2> >::value`

  1.*返回值：* 整数常量表达式.

  2.*值：* 2

  `tuple_element<0, pair<T1, T2> >::type`

  3.*值：* 类型T1

  `tuple_element<1, pair<T1, T2> >::type`

  4.*值：* 类型T2

  ```
  template<size_t I, class T1, class T2> 
  typename tuple_element<I, std::pair<T1, T2> >::type& get(pair<T1, T2>&) noexcept; 
  template<size_t I, class T1, class T2> 
  const typename tuple_element<I, std::pair<T1, T2> >::type& get(const pair<T1, T2>&) noexcept;
  ```

  5.*返回值：* 如果 I == 0 返回p.first;如果 I == 1 返回p.second;否则程序ill-formed.

  ```
  template<size_t I, class T1, class T2> 
  typename tuple_element<I, std::pair<T1, T2> >::type&& get(std::pair<T1, T2>&&) noexcept; 
  ```

  6.*返回值：* 如果 I == 0 返回std::forward<T1&&\>(p1.first);如果 I == 1 返回std::forward<T2&&\>(p.second);
  否则程序ill-formed.

  ### 20.3.5 分段构造(Piecewise construction)

  `struct piecewise_construct_t { };`

  `constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();`

  1.piecewise_construct_t是个空的结构体类型, 用作独特的类型来消除构造函数和函数重载的歧义.
  具体来说, pair具有一个piecewise_construct_t作为第一参数的构造函数, 随后是两个被用于pair对象的元素的分段构造的tuple元素

## 20.4
1. for align

  ### 20.4.1 概览

  1.本小节描述了提供tuple类型的tuple库, 该tuple类型可以作为可以使用任意数量的参数实例化的类模板tuple.
  每个模板参数指定tuple中元素的类型.因此, tuple是异构的固定大小的值集合.
  具有两个参数的tuple的实例化与具有相同两个参数的pair的实例化相似.见20.3.

  2.头文件 <tuple\> 概要

  ```
  namespace std {
    // 20.4.2, class template tuple:
    template <class... Types> class tuple;

    // 20.4.2.4, tuple creation functions:
    const unspecified ignore;

    template <class... Types>
    tuple<VTypes...> make_tuple(Types&&...);
    template <class... Types>
    tuple<Types...> forward_as_tuple(Types&&...) noexcept;

    template<class... Types>
    tuple<Types&...> tie(Types&...) noexcept;

    template <class... Tuples>
    tuple<Ctypes...> tuple_cat(Tuples&&...);

    // 20.4.2.5, tuple helper classes:
    template <class T> class tuple_size; // undeﬁned
    template <class T> class tuple_size<const T>;
    template <class T> class tuple_size<volatile T>;
    template <class T> class tuple_size<const volatile T>

    template <class... Types> class tuple_size<tuple<Types...> >;
    
    template <size_t I, class T> class tuple_element; // undeﬁned
    template <size_t I, class T> class tuple_element<I, const T>;
    template <size_t I, class T> class tuple_element<I, volatile T>;
    template <size_t I, class T> class tuple_element<I, const volatile T>;

    template <size_t I, class... Types> class tuple_element<I, tuple<Types...> >;

    // 20.4.2.6, element access:
    template <size_t I, class... Types>
    typename tuple_element<I, tuple<Types...> >::type& get(tuple<Types...>&) noexcept;
    template <size_t I, class... types>
    typename tuple_element<I, tuple<Types...> >::type&& get(tuple<Types...>&&) noexcept;
    template <size_t I, class... types>
    typename tuple_element<I, tuple<Types...> >::type const& get(const tuple<Types...>&) noexcept;

    // 20.4.2.7, relational operators:
    template<class... TTypes, class... UTypes>
    bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator<(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator!=(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator>(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator<=(const tuple<TTypes...>&, const tuple<UTypes...>&);
    template<class... TTypes, class... UTypes>
    bool operator>=(const tuple<TTypes...>&, const tuple<UTypes...>&);

    // 20.4.2.8, allocator-related traits 
    template <class... Types, class Alloc> 
    struct uses_allocator<tuple<Types...>, Alloc>;

    // 20.4.2.9, specialized algorithms: 
    template <class... Types> 
    void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(see below);
  } 
  ```

  ### 20.4.2 类模板tuple

  ```
  namespace std { 
    template <class... Types> 
    class tuple { 
    public: 
    
      // 20.4.2.1, tuple construction 
      constexpr tuple(); 
      explicit tuple(const Types&...); 
      template <class... UTypes> 
      explicit tuple(UTypes&&...);

      tuple(const tuple&) = default; 
      tuple(tuple&&) = default;

      template <class... UTypes> 
      tuple(const tuple<UTypes...>&); 
      template <class... UTypes> 
      tuple(tuple<UTypes...>&&);

      template <class U1, class U2> 
      tuple(const pair<U1, U2>&); // iﬀ sizeof...(Types) == 2 
      template <class U1, class U2> 
      tuple(pair<U1, U2>&&); // iﬀ sizeof...(Types) == 2
      
      // allocator-extended constructors 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, const Types&...); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, const UTypes&&...); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, const tuple&); 
      template <class Alloc> 
      tuple(allocator_arg_t, const Alloc& a, tuple&&); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&); 
      template <class Alloc, class... UTypes> 
      tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&); 
      template <class Alloc, class U1, class U2> 
      tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&); 
      template <class Alloc, class U1, class U2> 
      tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

      // 20.4.2.2, tuple assignment 
      tuple& operator=(const tuple&); 
      tuple& operator=(tuple&&) noexcept(see below);

      template <class... UTypes> 
      tuple& operator=(const tuple<UTypes...>&); 
      template <class... UTypes> 
      tuple& operator=(tuple<UTypes...>&&);

      template <class U1, class U2> 
      tuple& operator=(const pair<U1, U2>&); // iﬀ sizeof...(Types) == 2 
      template <class U1, class U2> 
      tuple& operator=(pair<U1, U2>&&) noexcept; // iﬀ sizeof...(Types) == 2 
      
      // 20.4.2.3, tuple swap 
      void swap(tuple&) noexcept(see below);
    };
  }
  ```

  #### 20.4.2.1 构造函数
  
  1.对每个构造函数来说, 仅在Types中的一个类型构造函数中抛出异常.

  2.In the constructor descriptions that follow, let i be in the range [0,sizeof...(Types)) in order, Ti be the ith type in Types, and Ui be the ith type in a template parameter pack named UTypes, where indexing is zero-based.

  `constexpr tuple();`
  
  3.*要求：* 每个i, is_default_constructible<Ti\>::value 是true.

  4.*影响：* 值初始化每个元素.

  `explicit tuple(const Types&...);`

  5.*要求：* 每个i, is_copy_constructible<Ti\>::value 是true.

  6.*影响：* 使用相应的参数初始化每个元素.

  `template <class... UTypes> explicit tuple(UTypes&&... u); `

  7.*要求：* sizeof...(Types)==sizeof...(UTypes). is_constructible<Ti, Ui&&\>::value is true for all i.

  8.*影响：* 用在std::forward<UTypes\>(u)中的相应的值初始化tuple中的每个元素.

  9.*备注：* 这个构造函数不参与重载决议, 除非每个UTypes中的类型可以隐式转换成在Types中对应的类型.

  `tuple(const tuple& u) = default;`

  10.*要求：* 每个i, is_copy_constructible<Ti\>::value 是true.

  11.*影响：* 用对应的u的元素初始化每个*this的元素 

  `tuple(tuple&& u) = default;`

  12.*要求：* 每个i, is_move_constructible<Ti\>::value 是true.

  13.*影响：* For all i, initializes the ith element of *this with std::forward<Ti\>(get<i\>(u)). 

  `template <class... UTypes> tuple(const tuple<UTypes...>& u);`

  14.*要求：*  sizeof...(Types) == sizeof...(UTypes). is_constructible<Ti, const Ui&\>::value is true for all i.

  15.*影响：* 用对应的u的元素构造每个*this的元素

  16.*备注：* 这个构造函数不参与重载决议, 除非每个i, const Ui&可以隐式转换到Ti.

  `template <class... UTypes> tuple(tuple<UTypes...>&& u);`

  17.*要求：*  sizeof...(Types)==sizeof...(UTypes). is_constructible<Ti, Ui&&\>::value is true for all i. 

  18.*影响：*   对全部i, std::forward<Ui\>(get<i\>(u))用初始化*this的第i个元素.

  19.*备注：* 这个构造函数不参与重载决议, 除非UTypes的每个类型可以隐式转换从在Types中对应的类型.

  `template <class U1, class U2> tuple(const pair<U1, U2>& u);`

  20.*要求：* sizeof...(Types) == 2. 
  对第一个类型T0来说, is_constructible<T0, const U1&\>::value 是true, 对第二个类型T1来说, is_constructible<T1, const U2&\>::value 是true

  21.*影响：* 用u.first构造第一个元素, u.second构造第二个元素.

  22.*备注：* 这个构造函数不参加重载决议, 除非const U1& 可隐式转换到T0, const U2& 可隐式转换到T1.

  `template <class U1, class U2> tuple(pair<U1, U2>&& u);`

  23.*要求：*  sizeof...(Types) == 2.
  对第一个类型T0来说, is_constructible<T0, U1&&\>::value 是true, 对第二个类型T1来说, is_constructible<T1, U2&&\>::value 是true. 

  24.*影响：* 用std::forward<U1\>(u.first)初始化第一个元素, std::forward<U2\>(u.second)初始化第二个元素.

  25.*备注：* 这个构造函数不参与重载决议, 除非U1可隐式转换到T0, U2可隐式转换到T1.

  ```
  template <class Alloc> 
  tuple(allocator_arg_t, const Alloc& a); 
  template <class Alloc> 
  tuple(allocator_arg_t, const Alloc& a, const Types&...); 
  template <class Alloc, class... UTypes> 
  tuple(allocator_arg_t, const Alloc& a, const UTypes&&...); 
  template <class Alloc> 
  tuple(allocator_arg_t, const Alloc& a, const tuple&); 
  template <class Alloc> 
  tuple(allocator_arg_t, const Alloc& a, tuple&&); 
  template <class Alloc, class... UTypes> 
  tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&); 
  template <class Alloc, class... UTypes> 
  tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&); 
  template <class Alloc, class U1, class U2> 
  tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&); 
  template <class Alloc, class U1, class U2> 
  tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
  ```

  26.*要求：* Alloc应该满足Allocator(17.6.3.5)的要求.

  27.*影响：* 等价于前面的构造函数, 不同之处在于每个元素都是使用uses_allocator(?)构造的.

  #### 20.4.2.2 赋值(Assignment)

  1.对于每个tuple赋值运算符, 仅当Types中的一种类型的赋值引发异常时, 才会引发异常.
  在下面的函数描述中, 按顺序让i在[0, sizeof ...(Types))范围内, Ti是Types中的第i个类型, Ui是名为UTypes的模板参数包中的第i个类型, 
  其中, index是从0开始的.

  `tuple& operator=(const tuple& u);`

  2.*要求：* 每个i, is_copy_assignable<Ti\>::value 是true.

  3.*影响：* 令每个u的元素赋值给对应的*this的元素.

  4.*返回值：* *this

  `tuple& operator=(tuple&& u) noexcept(see below);`

  5.*备注：* noexcept里的表达式等价于下面表达式的logical AND:

  ```
  is_nothrow_move_assignable<Ti>::value 
  ```

  Ti是Types里的第i个类型.

  6.*要求：* 每个i, is_move_assignable<Ti\>::value 是true.

  7.*影响：* 对于全部的i,令std::forward<Ti\>(get<i\>(u))赋值给get<i\>(*this).

  8.*返回值：* *this.

  `template <class... UTypes> tuple& operator=(const tuple<UTypes...>& u);`

  9.*要求：* sizeof...(Types) == sizeof...(UTypes).
  每个i, is_assignable<Ti&,const Ui&\>::value是true.

  10.*影响：* 令每个u的元素赋值给对应的*this的元素.

  11.*返回值：* *this

  `template <class... UTypes> tuple& operator=(tuple<UTypes...>&& u);`

  12.*要求：* 每个i, is_assignable<Ti&, Ui&&\>::value == true.
  sizeof...(Types) == sizeof...(UTypes). 

  13.*影响：* 每个i, 令std::forward<Ui\>(get<i\>(u))赋值给get<i\>(*this).

  14.*返回值：* *this.

  `template <class U1, class U2> tuple& operator=(const pair<U1, U2>& u);`

  15.*要求：* sizeof...(Types) == 2.
  对第一个类型T0来说, is_assignable<T0&, const U1&\>::value 是true.
  对第二个类型T1来说, is_assignable<T1&, const U2&\>::value 是true.

  16.*影响：* 令u.first赋值给*this的第一个元素, u.second赋值给 *this的第二个元素

  17.*返回值：* *this

  `template <class U1, class U2> tuple& operator=(pair<U1, U2>&& u);`

  18.*要求：* sizeof...(Types) == 2. 
  对第一个类型T0来说, is_assignable<T0&, U2&&\>::value 是true.
  对第二个类型T1来说, is_assignable<T1&, U2&&\>::value 是true.

  19.*影响：* 令std::forward<U1\>(u.first)赋值给*this的第一个元素, 
  std::forward<U2\>(u.second)赋值给 *this的第二个元素.

  20.*返回值：* *this

  #### 20.4.2.3 swap

  `void swap(tuple& rhs) noexcept(see below);`

  1.*备注：* noexcept里的表达式等价于下面表达式的logical：

  ```
  noexcept(swap(declval<Ti&>>(), declval<Ti&>())) 
  ```

  Ti是Types里的第i个类型.

  2.*要求：* 每个*this里的元素应该和rhs对应的元素可交换

  3.*影响:* 对*this的每个元素和rhs中相应的元素调用swap

  4.*Throws:* 无除非一个逐元素swap调用抛出异常.

  #### 20.4.2.4 创建tuple函数(Tuple creation functions)

  1.在下面的函数描述中, 按顺序让i在[0, sizeof ...(TTypes))范围内, 并让Ti为名为TTypes的模板参数包中的第i个类型； 
  让j按顺序在[0, sizeof ...(UTypes))范围内, 并且Uj是名为UTypes的模板参数包中的第j个类型, 其中index从0开始.

  `template<class... Types>`

  `tuple<VTypes...> make_tuple(Types&&... t);`

  2.每个i, Ui是decay<Ti\>::type.如果Ui等价于reference_wrapper<X\>,VTypes的每个Vi是X&, 否则Vi是Ui.

  3.*返回值：* tuple<VTypes...\>(std::forward<Types\>(t)...)

  4.[*Example:*
  ```
  int i; float j;
  make_tuple(i,ref(i),cref(j))
  创建一个如下类型的tuple
  tuple<int, int&, const float&>
  ```
  *-end example* ]

  `template <class... Tuples>`

  `tuple<CTypes...> tuple_cat(Tuples&&... tpls);`

  9.在以下各段中, 让Ti为tuple中的第i个类型, 让Ui为remove_reference<Ti\>::type, 
  并且tpi为函数参数包tpls中的第i个参数, 其中所有index均基于0.

  10.11.12.13 略

  #### 20.4.2.5 Tuple helper classes

  ```
  template <class... Types> 
  class tuple_size<tuple<Types...> > 
    : public integral_constant<size_t, sizeof...(Types)> { }; 
    
  template <size_t I, class... Types> 
  class tuple_element<I, tuple<Types...> > { 
  public: 
    typedef TI type; 
  }; 
  ```

  1.*要求：* I < sizeof...(Types).
  如果I越界, 程序ill-formed.

  2.*类型：* TI是Types的第I个元素的类型, index从0开始

  `template <class T> class tuple_size<const T>;`

  `template <class T> class tuple_size<volatile T>;`

  `template <class T> class tuple_size<const volatile T>;`

  3.让TS表示无cv类型T的tuple_size<T\>.
  然后三个模板中的每一个都应满足UnaryTypeTrait的要求, 
  其BaseCharacteristic是**integral_constant<remove_cv<decltype(TS::value)\>::type, TS::value\>**

  `template <size_t I, class T> class tuple_element<I, const T>;`

  `template <size_t I, class T> class tuple_element<I, volatile T>;`

  `template <size_t I, class T> class tuple_element<I, const volatile T>;`

  令TE表示无cv类型T的tuple_element<I, T\>.
  然后三个模板中的每一个都应满足TransformationTrait的要求, 
  成员typedef类型的名称如下：
    -第一个特化,add_const<TE::type\>::type,
    -第二个特化,add_volatile<TE::type\>::type,
    -第三个特化,add_cv<TE::type\>::type

  #### 20.4.2.6 元素访问(Element access)

  `template <size_t I, class... Types>`

  `typename tuple_element<I, tuple<Types...>>::type& get(tuple<Types...>& t) noexcept;`

  1.*要求：* I < sizeof...(Types).如果I越界, 程序ill-formed.

  2.*返回值：* t的第I个元素的引用, index从0开始.

  `template <size_t I, class... types>`

  `typename tuple_element<I, tuple<Types...>>::type&& get(tuple<Types...>&& t) noexcept;`

  3.*影响：* 等价于返回Equivalent to return std::forward<typename tuple_element<I, tuple<Types...\>\>::type&&\>(get<I\>(t));

  4.*Note:* 如果Types中的T是某个引用类型X&, 则返回类型为X&, 而不是X&&.
  但是, 如果元素类型为非引用类型T, 则返回类型为T&&.

  `template <size_t I, class... Types>`

  `typename tuple_element<I, tuple<Types...>>::type const& get(const tuple<Types...>& t) noexcept;`

  5.*要求：* I < sizeof...(Types).如果I越界, 程序ill-formed.

  6.*返回值：* t的第I个元素的const 引用, index从0开始.

  7.[*Note:*  Constness is shallow.如果Types中的T是某个引用类型X&,返回值是X&,而不是const X&.
  但是, 如果元素类型是非引用类型T, 返回类型是const T&.这与将constness定义为引用类型的成员变量的方式一致.
  *-end note*]

  8.[*Note:* get是一个非成员函数的理由是 如果实现了作为成员函数的这种设计, 
  依赖template参数的类型的代码需要使用template关键字.
  *-end note*]

  #### 20.4.2.7 相关运算符(Relational operators)

  `template<class... TTypes, class... UTypes>`

  `bool operator==(const tuple<TTypes...>& t, const tuple<UTypes...>& u);`

  1.*要求：* 每个i, 其中0 <= i和i < sizeof...（Types), get<i\>(t) == get<i\>(u)是有效表达式, 
  返回可转换为bool的类型. sizeof...(TTypes) == sizeof...(UTypes).

  2.*返回值：* 每个i, 如果get<i\>(t) == get<i\>(u), 返回true.对任意两个0长度的tuple e和f来说,e == f返回true.

  3.*影响：* 从0开始按顺序执行基本比较.在第一个相等比较结果为false之后, 不执行任何比较或元素访问.

  `template<class... TTypes, class... UTypes>`

  `bool operator<(const tuple<TTypes...>& t, const tuple<UTypes...>& u);`

  4.*要求：* 每个i, 其中0 <= i和i < sizeof...（Types), get<i\>(t) < get<i\>(u)和get<i\>(u) < get<i\>(t)是有效表达式, 
  返回可转换为bool的类型. sizeof...(TTypes) == sizeof...(UTypes).

  5.*影响：* t和u之前loxicographical比较的结果.结果定义如下：
  (bool)(get<0\>(t) < get<0\>(u)) ||  (!(bool)(get<0\>(u) < get<0\>(t)) && ttail < utail.
  其中某个tuple r的rtail是一个包含除r的第一个元素以外的所有元素的tuple.对于任何两个零长度tuple e和f, e < f返回false.

  ##### 剩下的和20.2.1/20.2.2要求一样

  #### 20.4.2.8 Tuple traits

  `template <class... Types, class Alloc>`

  `struct uses_allocator<tuple<Types...>, Alloc> : true_type { };`

  *要求：* Alloc应该是个Allocator(17.6.3.5).

  1.[*Note:* 此traits的特化informs其他库组件, 即使没有嵌套的allocator_type, 
  也可以使用alloctor构造tuple. *-end note*]

  #### 20.4.2.9 Tuple特化算法(Tuple specialized algorithms)

  `template <class... Types>`

  `void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(see below);`

  1.*备注：* noexcept里的表达式等价于：

    `noexcept(x.swap(y))`

  2.*影响：* x.swap(y).

## 20.5 类模板 bitset
1. for align

  ### 头文件<bitset\> 概要

  ```
  #include <string> 
  #include <iosfwd> // for istream, ostream 
  namespace std { 
    template <size_t N> class bitset;

    // 20.5.4 bitset operators: 
    template <size_t N> 
    bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept; 
    template <size_t N> 
    bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept; 
    template <size_t N> 
    bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept; 
    template <class charT, class traits, size_t N> 
    basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is, bitset<N>& x); 
    template <class charT, class traits, size_t N> 
    basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
  }
  ```

  1.头文件<bitset\>定义一个类模板和一些相关的函数, 用于表示和操作固定大小的位序列.

  ```
  namespace std { 
    template<size_t N> class bitset { 
    public: 
      // bit reference: 
      class reference { 
        friend class bitset; 
        reference() noexcept;
      public: 
        ~reference() noexcept; 
        reference& operator=(bool x) noexcept; // for b[i] = x; 
        reference& operator=(const reference&) noexcept; // for b[i] = b[j]; 
        bool operator~() const noexcept; // ﬂips the bit 
        operator bool() const noexcept; // for x = b[i]; 
        reference& flip() noexcept; // for b[i].flip(); 
      }; 

      // 20.5.1 constructors: 
      constexpr bitset() noexcept; 
      constexpr bitset(unsigned long long val) noexcept; 
      template<class charT, class traits, class Allocator> 
      explicit bitset(const basic_string<charT,traits,Allocator>& str, 
        typename basic_string<charT,traits,Allocator>::size_type pos = 0, 
        typename basic_string<charT,traits,Allocator>::size_type n = basic_string<charT,traits,Allocator>::npos, 
        charT zero = charT(’0’), charT one = charT(’1’)); 
      template <class charT> 
      explicit bitset(const charT* str, 
        typename basic_string<charT>::size_type n = basic_string<charT>::npos, 
        charT zero = charT(’0’), charT one = charT(’1’));

      // 20.5.2 bitset operations: 
      bitset<N>& operator&=(const bitset<N>& rhs) noexcept; 
      bitset<N>& operator|=(const bitset<N>& rhs) noexcept; 
      bitset<N>& operator^=(const bitset<N>& rhs) noexcept; 
      bitset<N>& operator<<=(size_t pos) noexcept; 
      bitset<N>& operator>>=(size_t pos) noexcept; 
      bitset<N>& set() noexcept; 
      bitset<N>& set(size_t pos, bool val = true); 
      bitset<N>& reset() noexcept; bitset<N>& reset(size_t pos); 
      bitset<N> operator~() const noexcept; bitset<N>& flip() noexcept; 
      bitset<N>& flip(size_t pos);
      
      // element access: 
      constexpr bool operator[](size_t pos) const; // for b[i]; reference 
      operator[](size_t pos); // for b[i];

      unsigned long to_ulong() const; 
      unsigned long long to_ullong() const; 
      template <class charT = char, 
          class traits = char_traits<charT>, 
          class Allocator = allocator<charT>> 
      basic_string<charT, traits, Allocator> 
      to_string(charT zero = charT(’0’), charT one = charT(’1’)) const; 
      size_t count() const noexcept; constexpr size_t size() noexcept; 
      bool operator==(const bitset<N>& rhs) const noexcept; 
      bool operator!=(const bitset<N>& rhs) const noexcept; 
      bool test(size_t pos) const; bool all() const noexcept; 
      bool any() const noexcept; bool none() const noexcept; 
      bitset<N> operator<<(size_t pos) const noexcept; 
      bitset<N> operator>>(size_t pos) const noexcept;
    };

    // 20.5.3 hash support
    template <class T> struct hash; 
    template <size_t N> struct hash<bitset<N>>;
  } 
  ```

  2.类模板bitset<N\>描述了一个可以保存由固定位数N组成的序列.

  3.每个bit表示值0(reset)或1(set).切换(toggle)一位是只将值0更改为1或者将值1更改为0.
  每个bit有一个非负位置pos.一个bitset<N\>对象和一些整型值互相转换时, bit位置pos对应*bit value*1<<pos.
  对应于两个或多个bit的整数值是它们的bit值之和.

  4.本节中描述的函数可以报告三种错误, 每种错误都与一个明显的异常相关：
  - 无效参数错误与invalid_argument类型的异常相关
  - 超出范围的错误与out_of_range类型的异常相关
  - 溢出错误与overflow_error类型的异常相关

  ### 20.5.1 bitset构造函数

  `constexpr bitset() noexcept;`

  1.*影响：* 构造一个bitset<N\>, 所有bit初始化为0.

  `constexpr bitset(unsigned long long val) noexcept;`

  2.*影响：* 构造一个bitset<N\>, 初始化其首（最低） M bit位置为对应 val 的位值, 
  其中 M 是 unsigned long long 的位数和正在构造的 bitset 中的位数 N 的较小者.
  如果 M 小于 N, 则剩余bit位置被初始化为零.

  `template <class charT, class traits, class Allocator>`

  `explicit bitset(const basic_string<charT, traits, Allocator>& str,`

  ` typename basic_string<charT, traits, Allocator>::size_type pos = 0,`

  ` typename basic_string<charT, traits, Allocator>::size_type n = basic_string<charT, traits, Allocator>::npos,`

  ` charT zero = charT(’0’), charT one = charT(’1’));`

  3.*要求：* pos <= str.size().

  4.*Throws:* 如果pos > str.size(),抛出 out_of_range.

  5.*影响：* 确定初始化string的有效长度rlen, rlen=min(n,str.size() - pos).

    如果在pos开头的任何其他字符都不为0或1, 则该函数将引发无效参数. 
    该函数使用traits::eq()比较字符值.

    否则, 该函数将构造一个bitset<N\>类的对象, 将第一个M bit位置初始化为由字符串str中相应字符确定的值.
    M是N和rlen中的较小者.

  6.如果str中从位置pos开始的相应字符为0, 则构造的字符串的元素的值为零.否则, 元素的值为1.
  字符位置pos + M-1对应于bit位置0.随后减少的字符位置对应于增加的bit位置.(?)

  7.如果 M < N, 剩余的bit位被初始化为0.

  `template <class charT>`

  `explicit bitset( const charT* str, `

  ` typename basic_string<charT>::size_type n = basic_string<charT>::npos,`

  ` charT zero = charT(’0’), charT one = charT(’1’));`

  8.*影响：* 构造一个bitset<N\>对象就像bitset( n == basic_string<charT\>::npos ? basic_string<charT\>(str) : basic_string<charT\>(str, n), 0, n, zero, one)

  ### 20.5.2 bitset members

  `bitset<N>& operator&=(const bitset<N>& rhs) noexcept;`

  1.*影响：* 清除*this中的每个bit, 为此清零rhs中对应的bit, 其他位保持不变.

  2.*返回值：* *this.

  `bitset<N>& operator|=(const bitset<N>& rhs) noexcept;`

  3.*影响：* set*this中的每个bit, 为此set rhs中对应的bit, 其他位保持不变.

  4.*返回值：* *this.

  `bitset<N>& operator^=(const bitset<N>& rhs) noexcept;`

  5.*影响：* 切换*this中的每个bit, 为此切换rhs中对应的bit, 其他位保持不变.

  6.*返回值：* *this.

  `bitset<N>& operator<<=(size_t pos) noexcept;`

  7.*影响：* 用一个确定的值按如下方式替换在*this中I位置的每个bit：
  - 如果 I < pos,新值是0;
  - 如果 I >= pos,新值是 I - pos 处先前的值.

  8.*返回值：* *this.

  `bitset<N>& operator>>=(size_t pos) noexcept;`

  9.*影响：* 用一个确定的值按如下方式替换在*this中I位置的每个bit：
  - 如果 pos >= N - I,新值是0;
  - 如果 pos < N -  I,新值是 I + pos 处先前的值.

  10.*返回值：* *this.

  `bitset<N>& set() noexcept;`

  11.*影响：* 设置*this的所有bit.

  12.*返回值：*  *this.

  `bitset<N>& set(size_t pos, bool val = true);`

  13.*要求：* pos是合理的.

  14.*Throws:* 如果pos不对应一个合理的bit位置, 抛出out_of_range.

  15.*影响：* 在*this中位置pos的bit中保存一个新值.如果val为非零, 则保存的值为1, 否则为0.

  16.*返回值：* *this.

  `bitset<N>& reset() noexcept;`

  17.*影响：* 重置*this的所有bit.

  18.*返回值：* *this.

  `bitset<N>& reset(size_t pos);`

  19.*要求：* pos是合理的.

  20.*Throws:* 如果pos不对应一个合理的bit位置, 抛出out_of_range.

  21.*影响：* 重置*this中在pos位置的bit.

  22.*返回值：* *this.

  `bitset<N> operator~() const noexcept;`

  23.*影响：* 构造一个bitset<N\>对象x并且用*this初始化.

  24.*返回值：* x.flip().

  `bitset<N>& flip() noexcept;`

  25.*影响：* 切换*this中所有bit.

  26.*返回值：* *this.

  `bitset<N>& flip(size_t pos);`

  27.*要求：* pos是合理的.

  28.*Throws:* 如果pos不对应一个合理的bit位置, 抛出out_of_range.

  29.*影响：* 切换*this中在pos位置的bit.

  30.*返回值：* *this.

  `unsigned long to_ulong() const;`

  31.*Throws:* 如果*this中的值不能被unsigned long表示, 抛出overflow_error.

  32.*返回值：* x.

  `unsigned long long to_ullong() const;`

  33.*Throws:* 如果*this中的值不能被unsigned long long表示, 抛出overflow_error.

  34.*返回值：* x.

  `template <class charT = char, class traits = char_traits<charT>, class Allocator = allocator<charT>>`

  `basic_string<charT, traits, Allocator> to_string(charT zero = charT(’0’), charT one = charT(’1’)) const; `

  35.*影响：* 构造一个合适的string对象并且用长度N的的字符初始化.每个字符通过*this中对应的bit位的值确定.
  字符位置N-1对应bit位置0.随后减少的字符位置对应于增加的bit位置.bit值0变成字符zero,bit值1变成字符one.

  36.*返回值：* 创建的对象.

  `size_t count() const noexcept;`

  37.*返回值：* *this中bit集合的位置的统计数.

  `constexpr size_t size() noexcept;`

  38.*返回值：* N.

  `bool operator==(const bitset<N>& rhs) const noexcept;`

  39.*返回值：* 如果*this中每bit的值等于rhs中对应bit的值, true.

  `bool operator!=(const bitset<N>& rhs) const noexcept;`

  40.*返回值：* 如果!(*this == rhs) ,  true.

  `bool test(size_t pos) const;`

  41.*要求：* pos是合理的.

  42.*Throws:* 如果pos不对应一个合理的bit位置, 抛出out_of_range.

  43.*返回值：* 如果*this中pos位置的bit是值1, true.

  `bool all() const noexcept;`

  44.*返回值：* count() == size().

  `bool any() const noexcept;`

  45.*返回值：* count() != 0.

  `bool none() const noexcept;`

  46.*返回值：* count() == 0.

  `bitset<N> operator<<(size_t pos) const noexcept;`

  47.*返回值：* bitset<N\>(*this) <<= pos.

  `bitset<N> operator>>(size_t pos) const noexcept;`

  48.*返回值：* bitset<N\>(*this) >>= pos.

  `constexpr bool operator[](size_t pos);`

  49.*要求：* pos是合理的.

  50.*返回值：* 如果*this中pos位置的bit是值1, true；否则false.

  51.*Throws:* Nothing.

  `bitset<N>::reference operator[](size_t pos);`

  52.*要求：* pos是合理的.

  53.*返回值：* 一个bitset<N\>::reference对象, (*this)[pos\] == this->test(pos) && (*this)[pos\] = val 等于 this->set(pos, val).

  54.*Throws:* Nothing.

  55.*备注：* 为了确定是否存在数据竞争, 通过结果引用进行的任何访问或更新都可能分别访问或修改整个基础bitset.

  ### 20.5.3 bitset hash support

  `template <size_t N> struct hash<bitset<N>>;`

  1.*要求：* 模板特化需满足类模板hash(20.8.12)的要求.

  ### 20.5.4 bitset 运算符

  `bitset<N> operator&(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;`

  1.*返回值：* bitset<N\>(lhs) &= rhs.

  `bitset<N> operator|(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;`

  2.*返回值：* bitset<N\>(lhs) |= rhs.

  `bitset<N> operator^(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;`

  3.*返回值：* bitset<N\>(lhs) ^= rhs.

  `template <class charT, class traits, size_t N>`

  `basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is, bitset<N>& x);`

  4.一个格式化输入函数.

  5.*影响：* 从is中提取最多N个字符.将这些字符保存在一个basic_string<charT, traits\>临时对象str中, 
  然后计算表达式x = bitset<N\>(str).N个字符被提取并保存直到发生以下任一情况:
    - N个字符被提取并保存.
    - 输入队列读取到eof.
    - 下一个输入字符既不是is.widen('0')也不是is.widen('1')(在这种情况下, 不会提取字符).

  6.如果没有字符保存在str,调用is.setstate(ios_base::failbit)(这可能会抛出ios_base::failure(27.5.5.4)).

  7.*返回值：* is.

  `template <class charT, class traits, size_t N>`

  `basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);`

  8.*返回值：* os << x.template to_string<charT,traits,allocator<charT\>\>(use_facet<ctype<charT\>\>(os.getloc()).widen(’0’),use_facet<ctype<charT\>\>(os.getloc()).widen(’1’))

## 20.6 Memory
1. for align

  ### 20.6.1 概览

  1.本条款描述了头文件<memory\>中的内容和一些C头文件<cstdlib\>,<cstring\>的内容.

  ### 20.6.2 头文件<memory\> 概要

  1.头文件<memory\>定义了几种类型和模板函数, 这些函数描述指针和类似指针的类型的属性, 
  管理容器和其他模板类型的内存管理, 并在单元化的内存缓冲区中构造多个对象.
  头文件定义模板unique_ptr, shared_ptr, weak_ptr和对这些类型的对象进行操作的各种模板函数(20.7).

  ```
  namespace std { 
    
    // 20.6.3, pointer traits 
    template <class Ptr> struct pointer_traits; 
    template <class T> struct pointer_traits<T*>;
    
    // 20.6.4, pointer safety 
    enum class pointer_safety { relaxed, preferred, strict }; 
    void declare_reachable(void *p); 
    template <class T> T *undeclare_reachable(T *p); 
    void declare_no_pointers(char *p, size_t n); 
    void undeclare_no_pointers(char *p, size_t n); 
    pointer_safety get_pointer_safety() noexcept;

    // 20.6.5, pointer alignment function 
    void *align(std::size_t alignment, std::size_t size, void *&ptr, std::size_t& space);

    // 20.6.6, allocator argument tag 
    struct allocator_arg_t { }; 
    constexpr allocator_arg_t allocator_arg = allocator_arg_t(); 
    
    // 20.6.7, uses_allocator 
    template <class T, class Alloc> struct uses_allocator;

    // 20.6.8, allocator traits 
    template <class Alloc> struct allocator_traits;

    // 20.6.9, the default allocator: 
    template <class T> class allocator; 
    template <> class allocator<void>; 
    template <class T, class U> bool operator==(const allocator<T>&, const allocator<U>&) noexcept; 
    template <class T, class U> bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;

    // 20.6.10, raw storage iterator: 
    template <class OutputIterator, class T> class raw_storage_iterator;

    // 20.6.11, temporary buﬀers: 
    template <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept; 
    template <class T> void return_temporary_buffer(T* p);

    // 20.6.12, specialized algorithms: 
    template <class T> T* addressof(T& r) noexcept;
    template <class InputIterator, class ForwardIterator> 
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result); 
    template <class InputIterator, class Size, class ForwardIterator> 
    ForwardIterator uninitialized_copy_n(InputIterator first, Size n, ForwardIterator result); 
    template <class ForwardIterator, class T> 
    void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x); 
    template <class ForwardIterator, class Size, class T> 
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);

    // 20.7.1 class template unique_ptr: 
    template <class T> class default_delete; 
    template <class T> class default_delete<T[]>; 
    template <class T, class D = default_delete<T>> class unique_ptr; 
    template <class T, class D> class unique_ptr<T[], D>;

    template <class T1, class D1, class T2, class D2> 
    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y); 
    template <class T1, class D1, class T2, class D2> 
    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y); 
    template <class T1, class D1, class T2, class D2> 
    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y); 
    template <class T1, class D1, class T2, class D2> 
    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y); 
    template <class T1, class D1, class T2, class D2> 
    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y); 
    template <class T1, class D1, class T2, class D2> 
    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

    template <class T, class D> 
    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept; 
    template <class T, class D> 
    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept; 
    template <class T, class D> 
    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept; 
    template <class T, class D> 
    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;
    template <class T, class D> 
    bool operator<(const unique_ptr<T, D>& x, nullptr_t); 
    template <class T, class D> 
    bool operator<(nullptr_t, const unique_ptr<T, D>& y); 
    template <class T, class D> 
    bool operator<=(const unique_ptr<T, D>& x, nullptr_t); 
    template <class T, class D> 
    bool operator<=(nullptr_t, const unique_ptr<T, D>& y); 
    template <class T, class D> 
    bool operator>(const unique_ptr<T, D>& x, nullptr_t); 
    template <class T, class D> 
    bool operator>(nullptr_t, const unique_ptr<T, D>& y); 
    template <class T, class D> 
    bool operator>=(const unique_ptr<T, D>& x, nullptr_t); 
    template <class T, class D> 
    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

    // 20.7.2.1, class bad_weak_ptr: 
    class bad_weak_ptr;

    // 20.7.2.2, class template shared_ptr: 
    template<class T> class shared_ptr;

    // 20.7.2.2.7, shared_ptr comparisons: 
    template<class T, class U> 
    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept; 
    template<class T, class U> 
    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept; 
    template<class T, class U> 
    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept; 
    template<class T, class U> 
    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept; 
    template<class T, class U> 
    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept; 
    template<class T, class U> 
    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

    template <class T> 
    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept; 
    template <class T> 
    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept; 
    template <class T> 
    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept; 
    template <class T> 
    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept; 
    template <class T> 
    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept; 
    template <class T> 
    bool operator<(nullptr_t, const shared_ptr<T>& y) noexcept; 
    template <class T> 
    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept; 
    template <class T> 
    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept; 
    template <class T> 
    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;
    template <class T> 
    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept; 
    template <class T> 
    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept; 
    template <class T> 
    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;

    // 20.7.2.2.8, shared_ptr specialized algorithms: 
    template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

    // 20.7.2.2.9, shared_ptr casts: 
    template<class T, class U> 
    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept; 
    template<class T, class U> 
    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept; 
    template<class T, class U> 
    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;

    // 20.7.2.2.10, shared_ptr get_deleter: 
    template<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;

    // 20.7.2.2.11, shared_ptr I/O: 
    template<class E, class T, class Y> 
    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);

    // 20.7.2.3, class template weak_ptr: 
    template<class T> class weak_ptr;

    // 20.7.2.3.6, weak_ptr specialized algorithms: 
    template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;

    // 20.7.2.3.7, class template owner_less: 
    template<class T> class owner_less;

    // 20.7.2.4, class template enable_shared_from_this: 
    template<class T> class enable_shared_from_this;

    // 20.7.2.5, shared_ptr atomic access: 
    template<class T> bool atomic_is_lock_free(const shared_ptr<T>* p);

    template<class T> shared_ptr<T> atomic_load(const shared_ptr<T>* p); 
    template<class T> shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);

    template<class T> void atomic_store(shared_ptr<T>* p, shared_ptr<T> r); 
    template<class T> void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

    template<class T> shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r); 
    template<class T> shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r,

    template<class T> bool atomic_compare_exchange_weak( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w); 
    template<class T> bool atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w); 
    template<class T> bool atomic_compare_exchange_weak_explicit( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w, memory_order success, memory_order failure); 
    template<class T> bool atomic_compare_exchange_strong_explicit( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w, memory_order success, memory_order failure);

    // 20.7.2.6 hash support 
    template <class T> struct hash; 
    template <class T, class D> struct hash<unique_ptr<T, D>>; 
    template <class T> struct hash<shared_ptr<T>>;

    // D.10, auto_ptr (deprecated) 
    template <class X> class auto_ptr;
  } 
  ```

  ### 20.6.3 Pointer traits

  1.类模板pointer_traits为类似指针的类型的某些属性提供了统一的接口.

  ```
  namespace std { 
    template <class Ptr> struct pointer_traits { 
      typedef Ptr pointer; 
      typedef see below element_type; 
      typedef see below difference_type;

      template <class U> using rebind = see below;

      static pointer pointer_to(see below r);
    };

    template <class T> struct pointer_traits<T*> { 
      typedef T* pointer; 
      typedef T element_type; 
      typedef ptrdiff_t difference_type;

      template <class U> using rebind = U*;
      static pointer pointer_to(see below r) noexcept;
    };
  }
  ```

  #### 20.6.3.1 Pointer traits member types

  `typedef see below element_type;`

  1.*类型：* 若存在则为 Ptr::element_type.否则若 Ptr 是模板实例化 Template<T, Args...\>则为T.
  ( Ptr::element_type if such a type exists; otherwise, T if Ptr is a class template instantiation of the form SomePointer<T, Args\>, where Args is zero or more type arguments; otherwise, the specialization is ill-formed.)

  `typedef see below difference_type;`

  2.*类型：* 若存在则为 Ptr::difference_type , 否则为 std::ptrdiff_t.

  `template <class U> using rebind = see below;`

  3.*别名模板：* 若存在则为 Ptr::rebind<U\> ,否则若 Ptr 是模板实例化Template<T, Args...\> 则为Template<U, Args...\>.

  #### 20.6.3.2 Pointer traits member functions

  `static pointer pointer_traits::pointer_to(see below r);`

  `static pointer pointer_traits<T*>::pointer_to(see below r) noexcept;`

  1.*备注：* 如果element_type(可能cv限定)是void,r是未指定的;否则,r是T&.

  2.*返回值：* 第一个模板函数返回通过调用Ptr::pointer_to(r)获得的指向r的可解引用的指针;如果Ptr没有一个匹配的静态成员函数pointer_to,这个函数的实例ill-formed.
  第二个模板函数返回std::addressof(r).

  ### 20.6.4 Pointer safety

  1.一个完整的对象被声明为reachable,而带有一个引用了该对象的参数对declare_reachable的调用次数超过了带有一个引用了该对象的参数对undeclare_reachable的调用次数.
  (A complete object is declared reachable while the number of calls to declare_reachable with an argument referencing the object exceeds the number of calls to undeclare_reachable with an argument referencing the object.)

  `void declare_reachable(void *p);`

  2.*要求：* p应该是安全派生的指针或null值.

  3.*影响：* 如果p非null,被p引用的完整对象随后被声明为reachable.

  4.*Throws:* 如果系统无法分配跟踪声明为reachable的对象可能需要的其他内存,则可能抛出std::bad_alloc.

  `template <class T> T *undeclare_reachable(T *p);`

  5.*要求：* 如果p非null,被p引用的完整对象应事先被声明为reachable,并且从调用时间到该对象的最后undeclare_reachable(p)调用应处于活跃状态.

  6.*返回值：* 一个p的安全派生的拷贝,它应等于p.

  7.*Throws:* Nothing.

  8.**

  546




export default ({ children }) => <Layout meta={meta}>{children}</Layout>
