import Layout from 'lib/components/layout'
import {} from '@zeit-ui/react'

export const meta = {
  title: 'General utilities library',
  date: '2020-03-22T03:46:59.795Z',
  description: '',
}

## 20.1 概览

1. 这个条款描述了在C++程序中广泛使用的工具；一些用于C++标准库的其他元素。

## 20.2 Utility components

1. 这个副条款包含了一些用于库的其余部分的基础函数和类模板。

  ### 头文件<utility\> 概要

2. 头文件<utility\>定义在这个条款里描述的若干类型和函数模板。
它也定义the template pair和大量用于pair对象操作的函数模板。

  ```
  #include <initializer_list>
  namespace std {
    // 运算符：
    namespace rel_ops {
      template<class T> bool operator!=(const T&, const T&);
      template<class T> bool operator> (const T&, const T&);
      template<class T> bool operator<=(const T&, const T&);
      template<class T> bool operator>=(const T&, const T&);
    }
    // swap：
    template <class T>
    constexpr void swap(T& a, T& b) noexcept(/* 见定义 */ );
    template <class T, size_t N>
    constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);
  
    // exchange：
    template <class T, class U=T> T exchange(T& obj, U&& new_val);
  
    // forward/move：
    template <class T>
    constexpr T&& forward(remove_reference_t<T>& t) noexcept;
    template <class T>
    constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
    template <class T>
    constexpr remove_reference_t<T>&& move(T&&) noexcept;
    template <class T>
    constexpr conditional_t<!is_nothrow_move_constructible_v<T>
                            && is_copy_constructible_v<T>, const T&, T&&>
    move_if_noexcept(T& x) noexcept;
  
    // as_const ：
    template <class T> constexpr add_const_t<T>& as_const(T& t) noexcept;
    template <class T> void as_const(const T&&) = delete;
  
    // declval：
    template <class T>
    add_rvalue_reference_t<T> declval() noexcept; // 作为不求值操作数
  
    // 编译时整数数列
    template<class T, T...> struct integer_sequence;
    template<size_t... I>
    using index_sequence = integer_sequence<size_t, I...>;
    template<class T, T N>
    using make_integer_sequence = integer_sequence<T, /* 见定义 */ >;
    template<size_t N>
    using make_index_sequence = make_integer_sequence<size_t, N>;
    template<class... T>
    using index_sequence_for = make_index_sequence<sizeof...(T)>;
  
    // pair：
    template <class T1, class T2> struct pair;
  
    // 对 pair 特化的算法：
    template <class T1, class T2>
    constexpr bool operator==(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator< (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator!=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator> (const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator>=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr bool operator<=(const pair<T1, T2>&, const pair<T1, T2>&);
    template <class T1, class T2>
    constexpr void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
    template <class T1, class T2>
    constexpr /* 见定义 */ make_pair(T1&&, T2&&);
  
    // 对 pair 的 tuple 式访问：
    template <class T> class tuple_size;
    template <size_t I, class T> class tuple_element;
    template <class T1, class T2> struct tuple_size<pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<0, pair<T1, T2>>;
    template <class T1, class T2> struct tuple_element<1, pair<T1, T2>>;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>&) noexcept;
    template<size_t I, class T1, class T2>
    constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&&) noexcept;
    template <class T, class U>
    constexpr T& get(pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<T, U>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<T, U>&& p) noexcept;
    template <class T, class U>
    constexpr T& get(pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr const T& get(const pair<U, T>& p) noexcept;
    template <class T, class U>
    constexpr T&& get(pair<U, T>&& p) noexcept;
    template <class T, class U>
    constexpr const T&& get(const pair<U, T>&& p) noexcept;
  
    // pair 逐段构造
    struct piecewise_construct_t { };
    constexpr piecewise_construct_t piecewise_construct{};
    template <class... Types> class tuple; // 定义于 <tuple>
  }
  ```

  ### 20.2.1 运算符

  1.为了避免多余定义，!=用==，>,<=和>=使用<。

  `template <class T> bool operator!=(const T& x, const T& y);`

  2.*要求：* T是EqualityComparable。

  3.*返回值：* !(x==y).

  `template <class T> bool operator>(const T& x, const T& y);`

  4.*要求：* T是LessThanComparable。

  5.*返回值：* y<x

  `template <class T> bool operator<=(const T& x, const T& y);`

  6.*要求：* T是LessThanComparable。

  7.*返回值：* !(y<x)

  `template <class T> bool operator>=(const T& x, const T& y);`

  8.*要求：* T是LessThanComparable。

  9.*返回值：* !(x<y)

  10.在这个库，每当对 != , > , >= , <= 进行声明时，
  并且未显示提供要求和语义，则要求和语义均在像本条款中指定的。

  ### 20.2.2 swap

  `template<class T> void swap(T& a, T& b) noexcept(see below);`

  1.*备注：* noexcept里的表达式等价于:

  ```
  is_nothrow_move_constructible<T>::value &&
  is_nothrow_move_assignable<T>::value
  ```

  2.*要求：* T应该是MoveConstructible和MoveAssignable。

  3.*影响:* 交换保存在两个位置的值。

  `template<class T, size_t N>`

  `void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));`

  4.*要求：* 对于[0,N\]内的所有i，a[i\]应可与b[i\]交换。

  5.*影响：* swap_ranges(a,a+N,b)

  ### 20.2.3 forward/move helpers

  1.该库提供了模板化的(helper)函数，以简化将移动语义应用于左值并简化转发功能的实现。

  `template <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;`

  `template <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept;`

  2.*返回值：* static_cast<T&&\>(t)

  3.如果第二个形式被一个左值引用实例化，程序ill-formed。

  4.[*Example:* 
  ```
    template <class T, class A1, class A2>
    shared_ptr<T> factory(A1&& a1, A2&& a2) { 
      return shared_ptr<T>(new T(std::forward<A1>(a1), std::forward<A2>(a2))); 
    }

    struct A { 
      A(int&, const double&); 
    };

    void g() { 
      shared_ptr<A> sp1 = factory<A>(2, 1.414); // error: 2 will not bind to int& 
      int i = 2; 
      shared_ptr<A> sp2 = factory<A>(i, 1.414); // OK 
    } 
  ```
  5.In the ﬁrst call to factory, A1 is deduced as int, so 2 is forwarded to A’s constructor as an rvalue. 
    In the second call to factory, A1 is deduced as int&, so i is forwarded to A’s constructor as an lvalue. 
    In both cases, A2 is deduced as double, so 1.414 is forwarded to A’s constructor as an rvalue.
    *-end note* \]

  6.[*Example:* 
    ```
    template <class T, class A1> 
    shared_ptr<T> factory(A1&& a1) { 
      return shared_ptr<T>(new T(std::forward<A1>(a1))); 
    }

    struct A { 
      A(); 
      A(const A&); // copies from lvalues 
      A(A&&); // moves from rvalues 
    };

    void g() { 
      A a; 
      shared_ptr<A> sp1 = factory<A>(a); // “a” binds to A(const A&) 
      shared_ptr<A> sp1 = factory<A>(std::move(a)); // “a” binds to A(A&&)
    }
    ```
  7.In the ﬁrst call to factory, A1 is deduced as A&, so a is forwarded as a non-const lvalue. 
    This binds to theconstructor A(const A&), which copies the value from a. 
    In the second call to factory, because of the call std::move(a),A1 is deduced as A,so a is forwarded as an rvalue. 
    This binds to the constructor A(A&&), which moves the value from a. 
    *-end note* \]

  `template <class T> typename conditional<`
  
  `!is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,`

  `const T&, T&&>::type move_if_noexcept(T& x) noexcept;`

  8.*返回值：* std::move(x)

  ### 20.2.4 函数模板declval

  1.该库提供函数模板declval,以简化对未求值运算符中出现的表达式的定义。

  `template <class T>`

  `typename add_rvalue_reference<T>::type declval() noexcept; // as unevaluated operand`

  2.*备注：* 如果这个函数被odr式使用，程序ill-formed

  3.*备注：* declval的模板参数T可能是未完成类型。

  [*Example:* 
  ```
  template <class To, class From> 
  decltype(static_cast<To>(declval<From>())) convert(From&&);
  ```
  声明一个函数模板convert,仅当From类型可以显式转换为To类型时，该转换才参与重载。
  有关另一个示例，请参见类模板common_type。
  *-end note*\]

## 20.3 Pairs

  ### 20.3.1 概览

  1.该库为合成值对提供了模板。 
  该库还提供了一个匹配功能模板以简化其构造，并提供了多个模板，
  这些模板可以访问配对对象，就像它们是tuple对象一样。

  ### 20.3.2 类模板pair

  ```
  // deﬁned in header <utility>

  namespace std { 
    template <class T1, class T2> 
    struct pair { 
      typedef T1 first_type; 
      typedef T2 second_type;

      T1 first; 
      T2 second; 
      pair(const pair&) = default; 
      pair(pair&&) = default;

      constexpr pair(); 
      pair(const T1& x, const T2& y); 
      template<class U, class V> pair(U&& x, V&& y); 
      template<class U, class V> pair(const pair<U, V>& p); 
      template<class U, class V> pair(pair<U, V>&& p); 
      template <class... Args1, class... Args2> 
      pair(piecewise_construct_t, tuple<Args1...> first_args, tuple<Args2...> second_args);

    pair& operator=(const pair& p); 
    template<class U, class V> pair& operator=(const pair<U, V>& p); 
    pair& operator=(pair&& p) noexcept(see below); 
    template<class U, class V> pair& operator=(pair<U, V>&& p);

    void swap(pair& p) noexcept(see below);
  };
}
```
1.构造函数和pair成员函数不会抛出异常，除非指定的对此操作调用的元素抛出异常。

`constexpr pair();`

2.*要求：* is_default_constructible<first_type\>::value 是 true and 
is_default_constructible<second_type\>::value 是 true.

3.*影响：* 值初始化first和second.

`pair(const T1& x, const T2& y);`

4.*要求：* is_copy_constructible<first_type\>::value 是 true and 
is_copy_constructible<second_type\>::value 是 true. 

5.*影响:* 这个构造函数用x初始化first，用y初始化second.

`template<class U, class V> pair(U&& x, V&& y);`

6.*要求：* is_constructible<first_type, U&&\>::value 是 true and 
is_constructible<second_type, V&&\>::value 是 true. 

7.*影响：* 这个构造函数用std::forward<U\>(x)初始化first，用std::forward<V\>(y)初始化second.

8.*备注：* 如果U不是隐式可转换到first_type或V不是隐式可转换到second_type的，这个构造函数不得参与重载决议。


export default ({ children }) => <Layout meta={meta}>{children}</Layout>
